<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imperialism Online: Roster Conquest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.4.0/dist/panzoom.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #00aaff;
            --text-color: #f0f0f0;
            --border-color: #444;
            --success-color: #4CAF50;
            --danger-color: #F44336;
            --warning-color: #ff9800;
            --font-main: 'Inter', sans-serif;
            --font-title: 'Russo One', sans-serif;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .screen {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }
        .screen.active { display: flex; }
        .container {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        h1, h2 {
            font-family: var(--font-title);
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }
        h3 {
             font-family: var(--font-title);
             margin-top: 15px;
             margin-bottom: 10px;
        }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input[type="number"], input[type="text"], input[type="url"] {
            width: 100%;
            padding: 12px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 1rem;
        }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            font-family: var(--font-title);
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            position: relative;
        }
        button:disabled { cursor: not-allowed; background-color: #555 !important; box-shadow: none !important; color: #999 !important; border-color: #555 !important; }
        .btn-primary { background-color: var(--primary-color); color: #fff; box-shadow: 0 0 15px var(--primary-color); }
        .btn-primary:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--primary-color); }
        .btn-secondary { background-color: var(--surface-color); color: var(--primary-color); border: 2px solid var(--primary-color); }
        .btn-secondary:not(:disabled):hover { background-color: var(--primary-color); color: #fff; }
        .btn-danger { background-color: var(--danger-color); color: #fff; box-shadow: 0 0 15px var(--danger-color); }
        .btn-danger:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--danger-color); }
        .game-code-display {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.5rem;
            font-family: var(--font-title);
            letter-spacing: 3px;
            border: 1px dashed var(--primary-color);
            cursor: pointer;
        }
        #player-list { list-style: none; padding: 0; }
        #player-list li { background: var(--bg-color); padding: 10px; border-radius: 5px; margin-bottom: 5px; }
        #player-list .host-tag { font-size: 0.8em; color: var(--primary-color); margin-left: 8px; }
        
        /* Roster Screen */
        .toggle-group { display: flex; gap: 10px; margin-bottom: 15px; }
        .toggle-group button { flex: 1; font-size: 0.9rem; padding: 10px; }
        .toggle-group button.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }

        #roster-list { max-height: 25vh; overflow-y: auto; margin-top: 15px; background-color: var(--bg-color); padding: 10px; border-radius: 8px;}
        .roster-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; border-bottom: 1px solid var(--border-color); }
        .roster-item:last-child { border-bottom: none; }
        .roster-item img { width: 40px; height: 40px; border-radius: 50%; margin-right: 15px; object-fit: cover;}
        .roster-item span { flex-grow: 1; }
        .roster-item button { padding: 5px 10px; font-size: 0.8rem; background-color: var(--danger-color); color: white; }

        #predefined-roster-view { display: none; }
        #predefined-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            max-height: 30vh;
            overflow-y: auto;
            padding: 10px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        .predefined-char {
            cursor: pointer;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid transparent;
            transition: transform 0.2s;
        }
        .predefined-char:hover {
            transform: scale(1.05);
            border-color: var(--primary-color);
        }
        .predefined-char img {
            width: 100%;
            display: block;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }
        .predefined-char.added {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .predefined-char.added::after {
            content: '✔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: var(--success-color);
            text-shadow: 0 0 5px black;
        }


        /* Lobby Screen */
        #lobby-screen .container { max-width: 800px; }
        .lobby-main-content {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .lobby-players { flex: 1.5; }
        #advantages-selection-container { 
            flex: 1; 
            background-color: var(--bg-color); 
            padding: 15px; 
            border-radius: 8px;
        }
        #advantages-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .advantage-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            padding: 5px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }
        .advantage-uses {
            font-size: 0.8rem;
            font-family: var(--font-title);
            color: var(--warning-color);
            line-height: 1;
        }
        .advantage-item:hover {
            border-color: var(--primary-color);
        }
        .advantage-item.selected {
            border-color: var(--success-color);
            background-color: rgba(76, 175, 80, 0.2);
        }
        .advantage-item.disabled:not(.selected) {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .advantage-item .tooltip, .player-advantage-btn .tooltip {
            /* Using display: none to prevent "sticky hover" issues on touch devices, where the invisible element can block subsequent taps. */
            display: none;
            width: 160px;
            background-color: #111;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 110%;
            left: 50%;
            margin-left: -80px;
            opacity: 0;
            font-size: 0.8rem;
            font-family: var(--font-main);
            pointer-events: none;
        }
        .advantage-item:hover .tooltip, .player-advantage-btn:hover .tooltip {
            display: block;
            opacity: 1;
        }


        /* Game Screen */
        #game-screen { width: 100vw; height: 100vh; padding: 0; }
        #arena-container { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            cursor: grab; 
            background-color: #111;
            background-image: radial-gradient(circle, #222 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #arena { display: grid; gap: 1px; transform-origin: center center; }
        .character-cell { 
            position: relative; 
            width: 100px; 
            height: 100px; 
            transition: all 0.5s ease;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        .character-cell img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .character-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.7); color: white; padding: 4px; font-size: 12px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        @keyframes roulette-highlight { 0%, 100% { box-shadow: 0 0 15px 5px #fff; } 50% { box-shadow: 0 0 25px 10px var(--primary-color); } }
        .roulette-active { animation: roulette-highlight 0.3s infinite; z-index: 10; transform: scale(1.05); }
        @keyframes target-highlight { 0%, 100% { box-shadow: 0 0 15px 5px var(--danger-color); transform: scale(1.05); } 50% { box-shadow: 0 0 25px 10px #ffdd00; transform: scale(1.1); } }
        .target-highlighted { animation: target-highlight 1s infinite; z-index: 10; }
        .attacker-selected { box-shadow: 0 0 20px 8px var(--success-color) !important; transform: scale(1.1); z-index: 10; }
        #game-ui-overlay { position: fixed; top: 20px; z-index: 100; left: 50%; transform: translateX(-50%);}
        
        #player-advantages-container-modal h3 {
            font-size: 0.9rem;
            text-align: center;
            margin-bottom: 10px;
            font-family: var(--font-title);
            color: var(--primary-color);
            margin-top: 25px;
        }
        .player-advantage-btn {
            font-size: 2rem;
            background: var(--surface-color);
            border: 2px solid var(--primary-color);
            width: 60px;
            height: 60px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .player-advantage-btn .advantage-uses {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .player-advantage-btn:hover:not(:disabled) {
            background-color: var(--primary-color);
        }
        .player-advantage-btn:disabled {
            background-color: #333;
            border-color: #555;
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Temporary Leaderboard */
        #temp-leaderboard {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 250px;
            max-height: 80vh;
            background: rgba(44, 44, 44, 0.85);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 15px;
            z-index: 100;
            backdrop-filter: blur(3px);
            overflow-y: auto;
            color: var(--text-color);
            display: none;
        }
        #temp-leaderboard h3 {
            font-family: var(--font-title);
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        #temp-leaderboard-list {
            list-style: none;
            padding-left: 0;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-rank {
            font-family: var(--font-title);
            font-size: 1.2rem;
            margin-right: 15px;
            width: 30px;
            text-align: center;
        }
        .leaderboard-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }
        .leaderboard-name {
            flex-grow: 1;
            font-size: 0.9rem;
        }

        /* Group Winners Sidebar */
        #group-winners-sidebar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 220px;
            max-height: 40vh;
            background: rgba(44, 44, 44, 0.85);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 10px;
            z-index: 100;
            backdrop-filter: blur(3px);
            color: var(--text-color);
            display: none;
            flex-direction: column;
        }
        #group-winners-sidebar h3 {
            font-family: var(--font-title);
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 1rem;
        }
        #group-winners-list {
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 5px;
        }
        .winner-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .winner-item img {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
        }
        .winner-item span {
            font-size: 0.8rem;
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }

        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 200; backdrop-filter: blur(5px); }
        .modal-content { background: var(--surface-color); padding: 40px; border-radius: 20px; text-align: center; width: 90%; max-width: 800px; box-shadow: 0 0 40px rgba(0, 170, 255, 0.5); border: 2px solid var(--primary-color); }
        .duel-container { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .combatant { display: flex; flex-direction: column; align-items: center; }
        .combatant img { width: 150px; height: 150px; object-fit: cover; border-radius: 50%; border: 5px solid var(--border-color); margin-bottom: 15px; }
        .combatant h3 { font-family: var(--font-title); font-size: 1.5rem; }
        .combatant .vote-count-display { font-size: 1rem; color: var(--warning-color); margin-top: 5px; height: 1.2em;}
        .vs { font-family: var(--font-title); font-size: 4rem; color: var(--danger-color); text-shadow: 0 0 10px var(--danger-color); }
        .vote-actions { display: flex; flex-direction: column; justify-content: center; gap: 15px; margin-top: 20px; max-width: 400px; margin-left: auto; margin-right: auto; }
        .vote-btn { width: 180px; margin: 0 auto; }
        #vote-timer { font-size: 2rem; margin-top: 15px; color: var(--warning-color); font-family: var(--font-title); }
        .reveal-section { display: none; margin-top: 20px; }
        .reveal-section h2 { font-size: 3rem; }
        .reveal-section p { font-size: 1.5rem; }
        .winner-reveal { color: var(--success-color); }
        .loser-reveal { color: var(--danger-color); }

        /* Results Screen */
        #results-screen .container { max-width: 800px; }
        #final-ranking-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #final-ranking-table th, #final-ranking-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
        #final-ranking-table th { font-family: var(--font-title); color: var(--primary-color); }
        #final-ranking-table .rank-img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; margin-right: 10px; vertical-align: middle; }
        
        /* Message Overlay */
        #message-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; justify-content: center; align-items: center; text-align: center; padding: 20px; pointer-events: none; }
        #message-overlay-content { background: rgba(44, 44, 44, 0.85); padding: 25px 35px; border-radius: 15px; text-shadow: 0 0 10px var(--primary-color); animation: pulse 2s infinite; pointer-events: all; }
        #message-overlay h2 { font-size: 2.5rem; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Chat Styles */
        #chat-toggle-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 101;
            width: 80px;
            height: 50px;
        }
        #chat-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            height: 400px;
            background-color: var(--surface-color);
            border: 2px solid var(--primary-color);
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(110%);
            opacity: 0;
            pointer-events: none;
        }
        #chat-container.open {
            transform: translateY(0);
            opacity: 1;
            pointer-events: all;
        }
        #chat-header {
            padding: 10px;
            background-color: var(--bg-color);
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-family: var(--font-title);
        }
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .chat-message.sent {
            background-color: var(--primary-color);
            color: #fff;
            align-self: flex-end;
        }
        .chat-message.received {
            background-color: var(--bg-color);
            align-self: flex-start;
        }
        .chat-sender {
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--warning-color);
        }
        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border-color);
        }
        #chat-input { flex-grow: 1; margin-right: 10px; }
        #chat-send-btn { font-size: 0.9rem; padding: 10px; }

    </style>
</head>
<body>

    <!-- Schermata Iniziale -->
    <div id="home-screen" class="screen active">
        <div class="container">
            <h1>Imperialism Online</h1>
            <p style="text-align: center; margin-bottom: 20px;">Crea una partita e invita i tuoi amici a votare, o unisciti a una partita come giudice!</p>
            <div class="form-group">
                <label for="player-name">Il tuo nome (giudice):</label>
                <input type="text" id="player-name" placeholder="Super Giudice" maxlength="20">
            </div>
            <div class="button-group">
                <button id="show-roster-config-btn" class="btn-primary">Crea Partita</button>
            </div>
            <hr style="margin: 20px 0; border-color: var(--border-color);">
            <div class="form-group">
                <label for="join-code">Codice Partita:</label>
                <input type="text" id="join-code" placeholder="ABCDE" maxlength="5">
            </div>
            <div class="button-group">
                <button id="join-game-btn" class="btn-secondary">Unisciti come Giudice</button>
            </div>
        </div>
    </div>

    <!-- Schermata Configurazione Roster (solo Host) -->
    <div id="roster-config-screen" class="screen">
        <div class="container">
            <h1>Configura Roster</h1>
            
            <h3>1. Scegli Modalità</h3>
             <div id="game-mode-toggle" class="toggle-group">
                <button id="mode-classic-btn" class="btn-secondary active" data-mode="classic">Classica</button>
                <button id="mode-tournament-btn" class="btn-secondary" data-mode="tournament">Torneo</button>
            </div>
            <p id="mode-description" style="font-size: 0.9em; text-align: center; margin-bottom: 20px;">Tutti contro tutti. Minimo 4 personaggi.</p>

            <h3>2. Aggiungi Personaggi</h3>
            <div class="toggle-group">
                <button id="show-custom-btn" class="btn-secondary active">Aggiungi con Link</button>
                <button id="show-predefined-btn" class="btn-secondary">Scegli dal Roster</button>
            </div>

            <div id="custom-add-view">
                <p>Aggiungi personaggi con nome e URL dell'immagine.</p>
                <div class="form-group">
                    <label for="char-name">Nome Personaggio:</label>
                    <input type="text" id="char-name" placeholder="Es. Son Goku">
                </div>
                <div class="form-group">
                    <label for="char-img">URL Immagine (PNG/JPG):</label>
                    <input type="url" id="char-img" placeholder="https://.../goku.png">
                </div>
                <button id="add-char-btn" class="btn-secondary">Aggiungi Personaggio</button>
            </div>

            <div id="predefined-roster-view">
                 <p>Clicca su un personaggio per aggiungerlo alla partita.</p>
                 <div id="predefined-grid"></div>
            </div>


            <h2 style="margin-top: 20px;">Personaggi Aggiunti</h2>
            <div id="roster-list"></div>
            <p id="char-counter" style="text-align: center; margin-top: 10px;">Personaggi: 0/120</p>
            <div class="button-group">
                <button id="create-lobby-btn" class="btn-primary" disabled>Crea Lobby (Min. 4)</button>
                <button id="back-to-home-btn" class="btn-danger">Annulla</button>
            </div>
        </div>
    </div>

    <!-- Schermata Lobby -->
    <div id="lobby-screen" class="screen">
        <div class="container">
            <div class="lobby-header" style="text-align: center;">
                <h1>Lobby di Gioco</h1>
                <p>Condividi questo codice con i tuoi amici (giudici):</p>
                <div id="game-code-display" class="game-code-display" title="Clicca per copiare">CARICAMENTO...</div>
            </div>
            <div class="lobby-main-content">
                <div class="lobby-players">
                    <h2 style="margin-top: 20px;">Giudici Connessi:</h2>
                    <ul id="player-list"></ul>
                </div>
                <div id="advantages-selection-container">
                    <h2>Scegli 2 Vantaggi</h2>
                    <div id="advantages-grid"></div>
                    <p style="font-size: 0.8rem; text-align: center; margin-top: 5px;">Potrai usarli una sola volta.</p>
                </div>
            </div>
            <div class="button-group">
                <button id="start-game-btn" class="btn-primary">Inizia Lotta!</button>
                <button id="leave-lobby-btn" class="btn-danger">Chiudi Lobby</button>
            </div>
        </div>
    </div>

    <!-- Schermata di Gioco -->
    <div id="game-screen" class="screen">
        <div id="game-ui-overlay">
             <button id="leave-game-btn" class="btn-danger">Abbandona</button>
        </div>
        <div id="temp-leaderboard">
            <h3>Classifica</h3>
            <ol id="temp-leaderboard-list"></ol>
        </div>
        <div id="arena-container">
            <div id="arena"></div>
        </div>
        
        <!-- Chat UI -->
        <div id="chat-container">
            <div id="chat-header">Chat di Gioco</div>
            <div id="chat-messages"></div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="Scrivi un messaggio...">
                <button id="chat-send-btn" class="btn-primary">Invia</button>
            </div>
        </div>
        <button id="chat-toggle-btn" class="btn-secondary">Chat</button>

        <!-- Group Winners Sidebar -->
        <div id="group-winners-sidebar">
            <h3>Vincitori Gironi</h3>
            <div id="group-winners-list"></div>
        </div>
    </div>
    
    <!-- Modale del Voto -->
    <div id="vote-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div id="vote-view">
                <h2>La Sfida!</h2>
                <div class="duel-container">
                    <div id="attacker-info" class="combatant"></div>
                    <div class="vs">VS</div>
                    <div id="defender-info" class="combatant"></div>
                </div>
                <h3>Chi vincerà? Vota!</h3>
                <div id="vote-actions" class="vote-actions"></div>
                <div id="player-advantages-container-modal" style="margin-top: 25px;">
                    <h3>I Tuoi Vantaggi</h3>
                    <div id="player-advantages-list-modal" class="vote-actions" style="flex-direction: row; flex-wrap: wrap;"></div>
                </div>
                <div id="vote-timer">15</div>
            </div>
            <div id="reveal-view" style="display: none;">
                <div id="winner-reveal" class="reveal-section winner-reveal">
                    <h2>SALVO!</h2>
                    <p id="winner-reveal-text"></p>
                </div>
                <div id="loser-reveal" class="reveal-section loser-reveal">
                    <h2>ELIMINATO!</h2>
                    <p id="loser-reveal-text"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modale Scudo del Destino -->
    <div id="shield-choice-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Scudo del Destino</h2>
            <p>Il tuo personaggio ha perso, ma puoi salvarne uno!</p>
            <p>Chi vuoi salvare dal duello?</p>
            <div id="shield-choice-actions" class="vote-actions">
                <!-- Buttons will be injected here -->
            </div>
        </div>
    </div>
    
    <!-- Modale Guardia del Corpo -->
    <div id="bodyguard-choice-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Guardia del Corpo</h2>
            <p>Scegli un personaggio da proteggere in questo duello.</p>
            <p>Se perderà, il duello finirà in pareggio.</p>
            <div id="bodyguard-choice-actions" class="vote-actions">
                <!-- Buttons will be injected here -->
            </div>
        </div>
    </div>

    <!-- Modale Tiro Mirato -->
    <div id="targeted-shot-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Tiro Mirato</h2>
            <p id="targeted-shot-winner-text"></p>
            <p>Scegli il suo prossimo avversario!</p>
            <div id="targeted-shot-actions" class="vote-actions">
                <!-- Buttons will be injected here -->
            </div>
        </div>
    </div>

    <!-- Schermata dei Risultati -->
    <div id="results-screen" class="screen">
        <div class="container">
            <h1 id="winner-announcement"></h1>
            <h2>Classifica Finale</h2>
            <table id="final-ranking-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Personaggio</th>
                        <th>Uccisioni</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <div class="button-group">
                <button id="rematch-btn" class="btn-primary">Rivincita!</button>
                <button id="new-game-btn" class="btn-secondary">Nuova Partita</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay per Messaggi -->
    <div id="message-overlay" style="display: none;">
        <div id="message-overlay-content">
            <h2 id="message-text"></h2>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, deleteDoc, runTransaction, addDoc, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyAu6Yy9B_VFAek56ZI35lznAlLzRv0G4pY",
            authDomain: "imperialism-online.firebaseapp.com",
            projectId: "imperialism-online",
            storageBucket: "imperialism-online.appspot.com",
            messagingSenderId: "1073749237649",
            appId: "1:1073749237649:web:b8c01c3db78a13fa454430",
            measurementId: "G-7GJK149KRR"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- RIFERIMENTI DOM ---
        const screens = document.querySelectorAll('.screen');
        const playerNameInput = document.getElementById('player-name');
        const showRosterConfigBtn = document.getElementById('show-roster-config-btn');
        const joinCodeInput = document.getElementById('join-code');
        const joinGameBtn = document.getElementById('join-game-btn');
        const backToHomeBtn = document.getElementById('back-to-home-btn');

        const modeClassicBtn = document.getElementById('mode-classic-btn');
        const modeTournamentBtn = document.getElementById('mode-tournament-btn');
        const modeDescription = document.getElementById('mode-description');
        const charNameInput = document.getElementById('char-name');
        const charImgInput = document.getElementById('char-img');
        const addCharBtn = document.getElementById('add-char-btn');
        const rosterList = document.getElementById('roster-list');
        const charCounter = document.getElementById('char-counter');
        const createLobbyBtn = document.getElementById('create-lobby-btn');
        const showCustomBtn = document.getElementById('show-custom-btn');
        const showPredefinedBtn = document.getElementById('show-predefined-btn');
        const customAddView = document.getElementById('custom-add-view');
        const predefinedRosterView = document.getElementById('predefined-roster-view');
        const predefinedGrid = document.getElementById('predefined-grid');
        
        const gameCodeDisplay = document.getElementById('game-code-display');
        const playerList = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        const advantagesGrid = document.getElementById('advantages-grid');

        const arenaContainer = document.getElementById('arena-container');
        const arena = document.getElementById('arena');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        const tempLeaderboard = document.getElementById('temp-leaderboard');
        const tempLeaderboardList = document.getElementById('temp-leaderboard-list');

        const playerAdvantagesContainerModal = document.getElementById('player-advantages-container-modal');
        const playerAdvantagesListModal = document.getElementById('player-advantages-list-modal');

        const voteModal = document.getElementById('vote-modal');
        const voteView = document.getElementById('vote-view');
        const revealView = document.getElementById('reveal-view');
        const attackerInfo = document.getElementById('attacker-info');
        const defenderInfo = document.getElementById('defender-info');
        const voteActions = document.getElementById('vote-actions');
        const voteTimer = document.getElementById('vote-timer');
        const winnerReveal = document.getElementById('winner-reveal');
        const loserReveal = document.getElementById('loser-reveal');
        const winnerRevealText = document.getElementById('winner-reveal-text');
        const loserRevealText = document.getElementById('loser-reveal-text');

        const shieldChoiceModal = document.getElementById('shield-choice-modal');
        const shieldChoiceActions = document.getElementById('shield-choice-actions');
        const bodyguardChoiceModal = document.getElementById('bodyguard-choice-modal');
        const bodyguardChoiceActions = document.getElementById('bodyguard-choice-actions');
        const targetedShotModal = document.getElementById('targeted-shot-modal');
        const targetedShotWinnerText = document.getElementById('targeted-shot-winner-text');
        const targetedShotActions = document.getElementById('targeted-shot-actions');

        const winnerAnnouncement = document.getElementById('winner-announcement');
        const finalRankingTableBody = document.querySelector('#final-ranking-table tbody');
        const rematchBtn = document.getElementById('rematch-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const messageOverlay = document.getElementById('message-overlay');
        const messageOverlayContent = document.getElementById('message-overlay-content');
        const messageText = document.getElementById('message-text');

        // Chat DOM References
        const chatContainer = document.getElementById('chat-container');
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');

        // --- STATO LOCALE ---
        let currentUser = null;
        let currentGameId = null;
        let unsubFromGame = null;
        let unsubFromChat = null;
        let panzoom;
        let localTimers = [];
        let localRoster = [];
        let animationInterval = null;
        let duelResolutionTimer = null;
        let isProcessingDuel = false;
        let selectedGameMode = 'classic';
        
        const advantages = {
            'extra_vote': { name: 'Voto Extra', emoji: '🗳️', description: 'Il tuo voto per questo round conta come due voti.' },
            'destiny_shield': { name: 'Scudo del Destino', emoji: '🛡️', description: 'Se il personaggio per cui hai votato perde, puoi scegliere di salvare uno dei due sfidanti, annullando il duello.' },
            'cancel_votes': { name: 'Voto Decisivo', emoji: '🚫', description: 'Tutti i voti degli altri giudici vengono azzerati. Solo il tuo conta.' },
            'calculated_chaos': { name: 'Caos Calcolato', emoji: '🎲', description: 'Annulla tutti i voti. Il vincitore del duello viene scelto casualmente.' },
            'revelation': { name: 'Rivelazione', emoji: '🔮', description: 'Rivela solo a te il conteggio dei voti in tempo reale.' },
            'forced_reversal': { name: 'Inversione Forzata', emoji: '🔄', description: 'Inverti i ruoli nel duello. L\'attaccante diventa il difensore e viceversa.' },
            'plot_twist': { name: 'Colpo di Scena', emoji: '🎭', description: 'Inverte i risultati del voto. Chi stava perdendo, vince.' },
            'bodyguard': { name: 'Guardia del Corpo', emoji: '🤝', description: 'Scegli uno sfidante. Se perde, non viene eliminato (pareggio).' },
            'last_word': { name: 'Ultima Parola', emoji: '📣', description: 'In caso di pareggio, il tuo voto decide il vincitore.' },
            'next_attacker_choice': { name: 'Tiro Mirato', emoji: '🎯', description: 'Scegli tu il prossimo avversario del vincitore di questo duello (tra quelli adiacenti).' }
        };

        const predefinedRoster = [
            { name: "Bojack Horseman", imgSrc: "https://i.pinimg.com/736x/00/6d/1d/006d1d9cf94575f074bc734734024292.jpg" },
            { name: "Coraline", imgSrc: "https://i.pinimg.com/736x/4b/62/cd/4b62cd6956f303b1950e7e897f4c4de5.jpg" },
            { name: "Daphne", imgSrc: "https://i.pinimg.com/1200x/d9/4f/17/d94f17af8588d344b6e9d552a3272476.jpg" },
            { name: "Dracula", imgSrc: "https://i.pinimg.com/1200x/bb/8b/c8/bb8bc834ea3b744b5031694080fb9d24.jpg" },
            { name: "Emily", imgSrc: "https://i.pinimg.com/736x/4a/b0/e4/4ab0e4436106abf64dd92c982c4dbf21.jpg" },
            { name: "Fred", imgSrc: "https://i.pinimg.com/736x/bc/aa/49/bcaa49d670b96cae19e35e957d15edd9.jpg" },
            { name: "Garfield", imgSrc: "https://i.pinimg.com/736x/56/f3/d3/56f3d3b914738b4ab2b436fb95e7b7de.jpg" },
            { name: "Gunter", imgSrc: "https://i.pinimg.com/736x/38/f7/fa/38f7fa5a9546ec2c83ef0d9c457ee1c3.jpg" },
            { name: "Jack", imgSrc: "https://i.pinimg.com/736x/c1/ff/6d/c1ff6d51ce518b1b87a8566d1ff248e0.jpg" },
            { name: "Kubo", imgSrc: "https://i.pinimg.com/1200x/55/40/10/554010f548dc400cf7a2355b8709bd43.jpg" },
            { name: "Lola", imgSrc: "https://i.pinimg.com/736x/4b/b3/7d/4bb37dd68bb53731dba3f5cc19d7d88a.jpg" },
            { name: "Luz", imgSrc: "https://i.pinimg.com/736x/c9/f0/a9/c9f0a9635abf9fa4058bc6b895482afc.jpg" },
            { name: "Mavis", imgSrc: "https://i.pinimg.com/736x/73/42/ac/7342ac705f31f9e9ceb9276b6208fed0.jpg" },
            { name: "Mordecai", imgSrc: "https://i.pinimg.com/736x/4f/2e/04/4f2e04cace599c4433a84b490d12c2a4.jpg" },
            { name: "Nermal", imgSrc: "https://i.pinimg.com/736x/43/42/6a/43426a422e7c4691836df283b409ae15.jpg" },
            { name: "Pizza Steve", imgSrc: "https://i.pinimg.com/736x/64/93/22/6493229bd2d371583e7b3d25167d56fb.jpg" },
            { name: "Porky Pig", imgSrc: "https://i.pinimg.com/736x/fc/aa/f7/fcaaf7fb2030a562f38fc005753792fd.jpg" },
            { name: "Principessa Fiamma", imgSrc: "https://i.pinimg.com/736x/ec/51/c1/ec51c196acd637c56d0db2fd6b73254e.jpg" },
            { name: "Rigby", imgSrc: "https://i.pinimg.com/736x/0f/00/07/0f0007bde9e6c2d7b982b003ef286377.jpg" },
            { name: "Scooby", imgSrc: "https://i.pinimg.com/1200x/41/8a/3a/418a3aa0ac6a/9140694f47bfda1cac0c.jpg" },
            { name: "Shaggy", imgSrc: "https://i.pinimg.com/736x/2b/c8/64/2bc864310eb133283ca305ec17ba4fbe.jpg" },
            { name: "Sharko", imgSrc: "https://i.pinimg.com/1200x/6b/6a/32/6b6a32a7a85d476d7025e1902f0f0f77.jpg" },
            { name: "Star", imgSrc: "https://i.pinimg.com/1200x/f4/66/21/f46621b643cda3e8950f83d432cbae88.jpg" },
            { name: "Tigre volante gigante", imgSrc: "https://i.pinimg.com/736x/20/27/e6/2027e674bdf384d6c7882fc53209a8d7.jpg" },
            { name: "Uncle Grandpa", imgSrc: "https://i.pinimg.com/1200x/d2/c1/ec/d2c1ec5830461c786ab77fa251dc08cc.jpg" },
            { name: "Velma", imgSrc: "https://i.pinimg.com/736x/2e/1e/95/2e1e953bb0b8a89d1574c0b221cd39b1.jpg" },
            { name: "Victor", imgSrc: "https://i.pinimg.com/1200x/6c/47/7b/6c477b1469500f36a2c8ab16339b1173.jpg" },
            { name: "Zig", imgSrc: "https://i.pinimg.com/736x/8d/06/65/8d0665e4088681dd0ee747b2d8da1e38.jpg" },
            { name: "Aang", imgSrc: "https://i.pinimg.com/736x/05/01/fc/0501fc8ed44f7bd4ad9e74d9bb959669.jpg" },
            { name: "Ada Wong", imgSrc: "https://i.pinimg.com/736x/19/ca/67/19ca678bedd73e74380204b75852e476.jpg" },
            { name: "Aladdin", imgSrc: "https://i.pinimg.com/736x/6c/07/fb/6c07fb41faa361b32f8c82020ba233a3.jpg" },
            { name: "Alejandro", imgSrc: "https://i.pinimg.com/1200x/e7/86/07/e78607796652e6e6f4b885f077837973.jpg" },
            { name: "Ametista", imgSrc: "https://i.pinimg.com/736x/11/b5/05/11b5056b41f87fbe3120b68ed5dcfb09.jpg" },
            { name: "Amy", imgSrc: "https://i.pinimg.com/1200x/17/e8/f1/17e8f14d01b7b69dc4099740ef5fb4dd.jpg" },
            { name: "Androide 18", imgSrc: "https://i.pinimg.com/736x/4c/68/ff/4c68ffd02e2220ec0b92f169f95d2e9f.jpg" },
            { name: "Ariel", imgSrc: "https://i.pinimg.com/736x/fe/a4/2e/fea42ebd0c67f19d1c0df8fe7a9c6613.jpg" },
            { name: "Auriana", imgSrc: "https://i.pinimg.com/1200x/15/44/0b/15440bfe0df83dad83a7330b96dcc72b.jpg" },
            { name: "B.O.B", imgSrc: "https://i.pinimg.com/736x/8c/c7/dc/8cc7dc812351093b69d55b34fee82e17.jpg" },
            { name: "Barbie", imgSrc: "https://i.pinimg.com/1200x/bd/e7/29/bde7296be641d72842be35b84065b48f.jpg" },
            { name: "Bayonetta", imgSrc: "https://i.pinimg.com/736x/8e/1e/cc/8e1eccca6c1a6b76fbc2e0a5a055f327.jpg" },
            { name: "Bean", imgSrc: "https://i.pinimg.com/1200x/45/d7/e2/45d7e2defb83d5694467fde7cf165dd9.jpg" },
            { name: "Belgim E.O", imgSrc: "https://m.media-amazon.com/images/M/MV5BODhhYWMxNzMtZGY2NS00MmM1LWI5OWItZjU1N2ZiNDA5NTI1XkEyXkFqcGc@._V1_.jpg" },
            { name: "Ben 10 (teen)", imgSrc: "https://i.pinimg.com/736x/ad/5c/cd/ad5ccdba073abda30c152f7eac48447b.jpg" },
            { name: "Bender", imgSrc: "https://i.pinimg.com/736x/17/e2/65/17e2654def74fcc7137d202fb48f7c9a.jpg" },
            { name: "Billy", imgSrc: "https://i.pinimg.com/736x/b6/55/a2/b655a2923fd04d20f9cf2520e8724536.jpg" },
            { name: "Blaze", imgSrc: "https://i.pinimg.com/736x/b8/89/61/b889619ef87861b12d6171172cf851a1.jpg" },
            { name: "Bloom", imgSrc: "https://i.pinimg.com/1200x/e0/b8/88/e0b8886f107836ff53010f9ab7dc0934.jpg" },
            { name: "Bowser", imgSrc: "https://i.pinimg.com/1200x/cf/3f/ec/cf3fec1f6b9334e0255065f150fa97a9.jpg" },
            { name: "Brago", imgSrc: "https://i.pinimg.com/1200x/7f/28/31/7f283141b761fee05de62cd51f4926ee.jpg" },
            { name: "Bugs Bunny", imgSrc: "https://i.pinimg.com/1200x/ff/d1/66/ffd166e976132eb05bf59b5339a01931.jpg" },
            { name: "Camilla", imgSrc: "https://i.pinimg.com/736x/47/c1/ff/47c1ffc1cb760fb9cd8bee66b4f8c57a.jpg" },
            { name: "Candace", imgSrc: "https://i.pinimg.com/736x/6c/72/f0/6c72f0fc188277b0996ab78fffe31729.jpg" },
            { name: "Carlos Oliveira", imgSrc: "https://i.pinimg.com/736x/9c/d7/61/9cd7611ff4aaceecd802b75a2d2ad1f6.jpg" },
            { name: "Chat Noir", imgSrc: "https://i.pinimg.com/736x/c3/ed/77/c3ed7755f4cbee4cd34316139d132597.jpg" },
            { name: "Chef Hatchet", imgSrc: "https://i.pinimg.com/1200x/4f/7c/8b/4f7c8bc30de9875dba940c17fcd6264a.jpg" },
            { name: "Clara", imgSrc: "https://i.pinimg.com/736x/7c/74/2a/7c742abdb8eab5753437213c31401b17.jpg" },
            { name: "Clarence", imgSrc: "https://i.pinimg.com/1200x/ed/50/84/ed5084c8f0cf0f3f7c9f60df18346c20.jpg" },
            { name: "Clover", imgSrc: "https://i.pinimg.com/1200x/72/4c/32/724c3291c00945fd0d7fe8b1052787b5.jpg" },
            { name: "Connie", imgSrc: "https://i.pinimg.com/736x/92/a2/30/92a2302a14c0116a861a0365d2c1583b.jpg" },
            { name: "Consuela", imgSrc: "https://i.pinimg.com/736x/bb/f0/ff/bbf0ff44ddf2003262e0ee7999ab5ea3.jpg" },
            { name: "Cortana", imgSrc: "https://i.pinimg.com/736x/00/93/12/0093124294f30d296f6c6155485c300c.jpg" },
            { name: "Corvina", imgSrc: "https://i.pinimg.com/736x/fc/e3/30/fce330b50ce9cbf53287e441be15d597.jpg" },
            { name: "Cosmo", imgSrc: "https://i.pinimg.com/736x/47/22/99/472299b4c669c052c662df1730403d83.jpg" },
            { name: "Courtney", imgSrc: "https://i.pinimg.com/1200x/0a/c5/52/0ac5521dddf64ab0b5d08e6e36a2c10b.jpg" },
            { name: "Crash", imgSrc: "https://i.pinimg.com/736x/98/e7/25/98e7251ed569efffda255ab33c0ffb11.jpg" },
            { name: "Cyborg", imgSrc: "https://i.pinimg.com/736x/bc/ef/b9/bcefb901b8a25aaf2716e142e9cf89a9.jpg" },
            { name: "Daffy Duck", imgSrc: "https://i.pinimg.com/736x/be/a3/7e/bea37edf64883f0cebaa6899c9fbad71.jpg" },
            { name: "Danny Phantom", imgSrc: "https://i.pinimg.com/736x/5e/5d/8a/5e5d8aa55ab87006f5a773b06299750e.jpg" },
            { name: "Darwin Watterson", imgSrc: "https://i.pinimg.com/736x/44/ad/5f/44ad5f25f6dae6e19757b15346684583.jpg" },
            { name: "Dave", imgSrc: "https://i.pinimg.com/736x/09/c8/6c/09c86cdb37c1ad86b793818f12c1d814.jpg" },
            { name: "Detective Conan", imgSrc: "https://i.pinimg.com/736x/77/e4/e9/77e4e9ddb6f514b151c15d16b0cf207d.jpg" },
            { name: "Dexter", imgSrc: "https://i.pinimg.com/736x/c8/68/e6/c868e63417b5653ac6f1bfb965cea28c.jpg" },
            { name: "Disgusto", imgSrc: "https://i.pinimg.com/736x/3c/04/b1/3c04b169f077246bebbe15a4557896f2.jpg" },
            { name: "Dolly", imgSrc: "https://i.pinimg.com/1200x/f6/cc/ad/f6ccadaefbf317d939a58c08a13bb8b8.jpg" },
            { name: "Doraemon", imgSrc: "https://i.pinimg.com/736x/b1/75/de/b175de80fb0f5ca9b5230f0b12f3c13c.jpg" },
            { name: "Duncan", imgSrc: "https://i.pinimg.com/1200x/a1/56/b1/a156b1d64b2e5309a8999be12c9a7247.jpg" },
            { name: "Edna", imgSrc: "https://i.pinimg.com/736x/04/02/3c/04023ce1f4c71fa3d0b18118753f5d13.jpg" },
            { name: "Eep", imgSrc: "https://i.pinimg.com/736x/99/be/fb/99befbf9776ca9c88c08c141e5ec507c.jpg" },
            { name: "Eli Shane", imgSrc: "https://i.pinimg.com/736x/00/2a/8c/002a8c4259c1d4ee38792ef48bf901f1.jpg" },
            { name: "Elsa", imgSrc: "https://i.pinimg.com/736x/fd/26/cd/fd26cd346c9e73430dc9ba28e318fb74.jpg" },
            { name: "Empoleon", imgSrc: "https://i.pinimg.com/1200x/b2/52/ea/b252eac40b5327d0691ddf9e6c9ec7d3.jpg" },
            { name: "Eric Cartman", imgSrc: "https://i.pinimg.com/736x/31/3a/b7/313ab7f6d385f544ffc90681ae08c117.jpg" },
            { name: "Ferb", imgSrc: "https://i.pinimg.com/736x/63/04/d3/6304d368076442119f65936ca107067c.jpg" },
            { name: "Ferocia", imgSrc: "https://i.pinimg.com/736x/9c/31/15/9c31155d6aa8c5ee9b807c9d022d0fcb.jpg" },
            { name: "Finn", imgSrc: "https://i.pinimg.com/736x/29/83/75/298375aacfcc94f3310fad5578000f6d.jpg" },
            { name: "Francine Smith", imgSrc: "https://i.pinimg.com/736x/18/c1/d2/18c1d2489a64b1b4f9cc78318e62da94.jpg" },
            { name: "Ganyu", imgSrc: "https://i.pinimg.com/736x/ee/d6/41/eed6413f9bde5936c76cd8a0a96fcc3a.jpg" },
            { name: "Garnet", imgSrc: "https://i.pinimg.com/736x/65/9b/d2/659bd260c80c7ecb1e2c1d7c7c3e9508.jpg" },
            { name: "Giyu", imgSrc: "https://i.pinimg.com/736x/fa/78/dd/fa78ddb22728f7ae661b3c18615d1d68.jpg" },
            { name: "Gloria", imgSrc: "https://i.pinimg.com/736x/a3/9d/52/a39d524c0413fac8377305e44452a869.jpg" },
            { name: "Goku", imgSrc: "https://i.pinimg.com/1200x/be/2c/ca/be2cca993b93995cc2a364201ae925a3.jpg" },
            { name: "Gommarosa", imgSrc: "https://i.pinimg.com/736x/27/3e/df/273edf0076e41b90096717b89e04c1aa.jpg" },
            { name: "Gretchen", imgSrc: "https://i.pinimg.com/736x/17/89/52/178952f924a0f5dad307f42777d43512.jpg" },
            { name: "Grizzly", imgSrc: "https://i.pinimg.com/1200x/2c/0a/98/2c0a980377e0a6befa3b4e7fb50be361.jpg" },
            { name: "Gruk", imgSrc: "https://i.pinimg.com/736x/4f/d0/97/4fd097204b8ce94fc06f0f52eec422d2.jpg" },
            { name: "Gumball", imgSrc: "https://i.pinimg.com/736x/af/61/0f/af610f55e819f4bd3f37e5001a2b19ee.jpg" },
            { name: "Gwen", imgSrc: "https://i.pinimg.com/736x/3e/67/48/3e6748b9ba3f30cda452f7209bba5037.jpg" },
            { name: "Hayley", imgSrc: "https://i.pinimg.com/1200x/7b/72/e6/7b72e614ce0b79c150ce3e3f7ec57e53.jpg" },
            { name: "Heather", imgSrc: "https://i.pinimg.com/1200x/ff/24/d2/ff24d2d8c493586d4f787f3e8c49f350.jpg" },
            { name: "Homer Simpson", imgSrc: "https://i.pinimg.com/1200x/1d/b9/18/1db918fe2b5dff69f35186ad20cc1752.jpg" },
            { name: "Iris", imgSrc: "https://i.pinimg.com/736x/df/91/2c/df912ce5589e1cc86d58c100ef836102.jpg" },
            { name: "Jake", imgSrc: "https://i.pinimg.com/736x/00/07/e5/0007e54a9a0d180850ed97718df1e432.jpg" },
            { name: "James", imgSrc: "https://i.pinimg.com/736x/c7/86/6f/c7866f0aaa71ed0ee10f2c57c84354d9.jpg" },
            { name: "Jamie", imgSrc: "https://i.pinimg.com/1200x/1a/77/9f/1a779f8f3bb1864d26cbcd93dbd50606.jpg" },
            { name: "Jerry", imgSrc: "https://i.pinimg.com/736x/be/2f/e1/be2fe1bde39e5005bdc4cea479dcf6f7.jpg" },
            { name: "Jessie", imgSrc: "https://i.pinimg.com/736x/ee/fe/10/eefe109155e2672ddd5dc35e3835d7b6.jpg" },
            { name: "Johnny Bravo", imgSrc: "https://i.pinimg.com/736x/b4/cd/95/b4cd959a9bb7efaf289ba3e4ae85d4b8.jpg" },
            { name: "Johnny Test", imgSrc: "https://i.pinimg.com/736x/a7/2d/cd/a72dcd2fecd65b9f49fc0e0fe5d4f08b.jpg" },
            { name: "Katara", imgSrc: "https://i.pinimg.com/736x/00/14/5e/00145ebb0ae3ae4b2af824d831faf313.jpg" },
            { name: "Kirby", imgSrc: "https://i.pinimg.com/736x/ba/e6/63/bae6637b3efecfd002f0c1f9605e53be.jpg" },
            { name: "Kratos", imgSrc: "https://i.pinimg.com/736x/d9/d4/4f/d9d44f16329a4e72b4b8e45d41d83262.jpg" },
            { name: "Ladybug", imgSrc: "https://i.pinimg.com/736x/72/32/f1/7232f16bdab9dd11a2fa77403a1fe9f1.jpg" },
            { name: "Lapis", imgSrc: "https://i.pinimg.com/1200x/09/fb/12/09fb12467957da96913fc8f75e6f6356.jpg" },
            { name: "Leela", imgSrc: "https://i.pinimg.com/1200x/6e/c8/b6/6ec8b67dc6bb062afc2007495b041e84.jpg" },
            { name: "Leon Kennedy", imgSrc: "https://i.pinimg.com/736x/0a/27/cd/0a27cd44aae181df0884d85bf18d0574.jpg" },
            { name: "Leone", imgSrc: "https://i.pinimg.com/736x/e7/39/42/e73942ae0951adead9eb1c325ccbc278.jpg" },
            { name: "Link", imgSrc: "https://i.pinimg.com/736x/be/29/0a/be290ac4f5b6f1de6f88ee2099e04da1.jpg" },
            { name: "Lok Lamberk", imgSrc: "https://i.pinimg.com/736x/e4/2f/00/e42f00392808fe1283088f26d7dc3680.jpg" },
            { name: "Luci", imgSrc: "https://i.pinimg.com/736x/ac/3d/7a/ac3d7a22d32d85f1a4c8bed9eeff0b75.jpg" },
            { name: "Lucinda", imgSrc: "https://i.pinimg.com/736x/14/8b/b1/148bb1d4e05a07005790f152273ae2be.jpg" },
            { name: "Luigi", imgSrc: "https://i.pinimg.com/1200x/0b/49/30/0b49308522463829166e76b0d914c8b8.jpg" },
            { name: "Mandy", imgSrc: "https://i.pinimg.com/736x/60/95/01/60950157128f9671609b5dcf0788553d.jpg" },
            { name: "Marceline", imgSrc: "https://i.pinimg.com/736x/bb/93/5e/bb935e39f2d66248b6e4178227bdb233.jpg" },
            { name: "Marge", imgSrc: "https://i.pinimg.com/736x/4a/92/1d/4a921da60b6e183b05ca430e93591319.jpg" },
            { name: "Mario", imgSrc: "https://i.pinimg.com/736x/61/62/b5/6162b56bc61a4050bb34d7203e03642d.jpg" },
            { name: "Mary", imgSrc: "https://i.pinimg.com/1200x/4c/a0/e1/4ca0e19e9a0ade6f357363437e2e21b2.jpg" },
            { name: "Mcgee", imgSrc: "https://i.pinimg.com/736x/f6/66/e6/f666e6b35b12c28ac454d7b71e4dcd93.jpg" },
            { name: "Meg", imgSrc: "https://i.pinimg.com/1200x/fc/08/05/fc080502466c0c9a0d48433022fe507d.jpg" },
            { name: "Mortino", imgSrc: "https://i.pinimg.com/1200x/a6/40/79/a64079d581a91443333e800939bed57a.jpg" },
            { name: "Naruto", imgSrc: "https://i.pinimg.com/736x/22/3f/a8/223fa84e2e_58598d27a6d733b5ff99e7.jpg" },
            { name: "Nicole", imgSrc: "https://i.pinimg.com/736x/95/88/32/958832447418773426ae7f9bd2fdf38b.jpg" },
            { name: "Patrick", imgSrc: "https://i.pinimg.com/736x/a9/3b/10/a93b10ac7fd73a731efedb50bfbbc1c3.jpg" },
            { name: "Peppa Pig", imgSrc: "https://i.pinimg.com/1200x/45/b2/88/45b28859333ddcb2470ae59f88d56093.jpg" },
            { name: "Peridot", imgSrc: "https://i.pinimg.com/736x/d5/3e/f6/d53ef6f0ec684f7f0f888971dded59fb.jpg" },
            { name: "Perry", imgSrc: "https://i.pinimg.com/736x/6a/77/65/6a7765e22f89b8bceead355ce8fe5982.jpg" },
            { name: "Peter", imgSrc: "https://i.pinimg.com/736x/9e/40/74/9e4074bbe7890cd245b51b9ff5c0e33c.jpg" },
            { name: "Po", imgSrc: "https://i.pinimg.com/1200x/c1/c3/27/c1c327391c8cbd539d7a2555e2b9051d.jpg" },
            { name: "Ponygon", imgSrc: "https://i.pinimg.com/1200x/4a/ee/29/4aee29b5bc03c3f3dfbec858428e86a9.jpg" },
            { name: "Quagmire", imgSrc: "https://i.pinimg.com/736x/02/ee/2a/02ee2a26595b79605e549d31636c8904.jpg" },
            { name: "Rayman", imgSrc: "https://i.pinimg.com/736x/dd/fb/39/ddfb395a795475f82f0c5d4286f47bd3.jpg" },
            { name: "Re Julien", imgSrc: "https://i.pinimg.com/736x/65/3b/19/653b190d1e98314d75c33faa946d144d.jpg" },
            { name: "Richard", imgSrc: "https://i.pinimg.com/736x/3f/57/61/3f5761972402157f6969c91edc160322.jpg" },
            { name: "Rick", imgSrc: "https://i.pinimg.com/736x/71/c3/46/71c3461ace4e33b9522d4c1982dbbe3d.jpg" },
            { name: "Rico", imgSrc: "https://i.pinimg.com/1200x/54/29/6c/54296cbbb7164959bb91a10d5d99c9e9.jpg" },
            { name: "Robin GO", imgSrc: "https://i.pinimg.com/736x/92/b6/50/92b650adbe57c5cec55a3ef46b65e933.jpg" },
            { name: "Roger", imgSrc: "https://i.pinimg.com/736x/5c/32/97/5c32974e70a02bbccbd5eb22e2572daf.jpg" },
            { name: "Rosalinda", imgSrc: "https://i.pinimg.com/736x/da/7d/ea/da7deae0392afdba03699bf98806ec38.jpg" },
            { name: "Sam", imgSrc: "https://i.pinimg.com/736x/e9/b1/0c/e9b10cb8868e19f0a2ea254fca79b519.jpg" },
            { name: "Shrek", imgSrc: "https://i.pinimg.com/1200x/96/0b/6a/960b6a68e0f1d861d143b55aa84059e6.jpg" },
            { name: "Signorina Scimmia", imgSrc: "https://i.pinimg.com/1200x/d4/8c/c7/d48cc793b03983680d00449e7eda388c.jpg" },
            { name: "Simba", imgSrc: "https://i.pinimg.com/736x/72/b4/a8/72b4a8fab22d9a4a2f274932f440afe2.jpg" },
            { name: "Skipper", imgSrc: "https://i.pinimg.com/736x/f7/93/48/f79348f7e7f2123575ec9288963c7322.jpg" },
            { name: "Spinel", imgSrc: "https://i.pinimg.com/736x/d2/78/b0/d278b0606af1be5a2fb8ebf69dfca045.jpg" },
            { name: "Spongebob", imgSrc: "https://i.pinimg.com/736x/9d/43/03/9d4303eb6df9cf9e6ca76a255c0147d5.jpg" },
            { name: "Squiddi", imgSrc: "https://i.pinimg.com/736x/39/8b/d2/398bd2710ceaf3d07b44ce0b4c130da2.jpg" },
            { name: "Squitto", imgSrc: "https://i.pinimg.com/736x/0a/d9/e8/0ad9e808910fb1cd86a259a39d694a64.jpg" },
            { name: "Squirt", imgSrc: "https://i.pinimg.com/1200x/07/6d/ba/076dba0b7e5db623077963add2caf810.jpg" },
            { name: "Stan", imgSrc: "https://i.pinimg.com/736x/7b/8b/a8/7b8ba8449f8d471eac4e033a00acc2ed.jpg" },
            { name: "Stellarubia", imgSrc: 'https://i.pinimg.com/736x/fe/0f/50/fe0f502c141c3c69054e22fc539199b0.jpg' },
            { name: "Stitch", imgSrc: "https://i.pinimg.com/1200x/0b/00/9f/0b009f581cfd02d093d8f7850df93582.jpg" },
            { name: "Superboy", imgSrc: "https://i.pinimg.com/736x/e3/b6/9e/e3b69e2535013ad4fe46a0187dfd007b.jpg" },
            { name: "Talia", imgSrc: "https://i.pinimg.com/736x/b4/7f/c4/b47fc4659d4ff98cc6258b414a8cc4c7.jpg" },
            { name: "Timmy", imgSrc: "https://i.pinimg.com/736x/cb/6b/6e/cb6b6e48d342bd40daba5031f598d4af.jpg" },
            { name: "Titeuf", imgSrc: "https://i.pinimg.com/736x/44/98/b1/4498b1862c5e19112d8dbe89495925a3.jpg" },
            { name: "Tom", imgSrc: "https://i.pinimg.com/1200x/e2/d2/c9/e2d2c9858d0a002a45d68ba97d477b0e.jpg" },
            { name: "Trixie", imgSrc: "https://i.pinimg.com/736x/16/f7/3b/16f73b7c2512a837cdce35a6ccaa4df4.jpg" },
            { name: "Waluigi", imgSrc: "https://i.pinimg.com/736x/0e/e2/93/0ee2931b7e07fa1d1949f4d41b9b4e93.jpg" },
            { name: "Wanda", imgSrc: "https://i.pinimg.com/1200x/fd/b3/ba/fdb3bada328ff3eb5aff2cc8c5bc92d1.jpg" },
            { name: "Wario", imgSrc: "https://i.pinimg.com/736x/07/72/16/07721681614a459938a7f85ec450f957.jpg" },
            { name: "Wasabi", imgSrc: "https://i.pinimg.com/736x/f7/e8/ae/f7e8aef1d5825948ce19c99a0996e959.jpg" },
            { name: "Yang", imgSrc: "https://i.pinimg.com/736x/67/19/2c/67192c45308be09379c7841bf866a480.jpg" },
            { name: "Ying", imgSrc: "https://i.pinimg.com/1200x/13/b4/ff/13b4ff2998c7f763004788fd67468e61.jpg" },
            { name: "Yugo", imgSrc: "https://i.pinimg.com/1200x/64/d9/58/64d9583ffc1afad8801766065e64959a.jpg" },
            { name: "Zatch Bell", imgSrc: "https://i.pinimg.com/1200x/35/9c/9e/359c9e3e0530e20c95754847066e8167.jpg" },
            { name: "Zick", imgSrc: "https://i.pinimg.com/1200x/14/e6/05/14e6054b56e4e2379936c00403566c00.jpg" },
            { name: "Papà di timmy", imgSrc: "https://i.pinimg.com/736x/f1/0d/b2/f10db23a208fb72719c45114904f2f2f.jpg" },
            { name: "Victoream", imgSrc: "https://media.tenor.com/TXAwIpf-FBkAAAAe/zatch-bell-victoream.png" },
            { name: "Mia", imgSrc: "https://i.pinimg.com/736x/71/ca/24/71ca24e0962551c9f222b804a629d493.jpg" },
            { name: "Shizuka", imgSrc: "https://i.pinimg.com/736x/00/9b/f3/009bf3acc306645251d0b91fd5855b12.jpg" },
            { name: "Ispettore Gadget", imgSrc: "https://i.pinimg.com/1200x/15/fa/86/15fa8685007e39c2cfaceb57cc92a93a.jpg" },
            { name: "Lincoln", imgSrc: "https://i.pinimg.com/736x/f4/11/15/f411158f77bbbc7f8ef9705e1c5efcef.jpg" },
            { name: "Luna", imgSrc: "https://i.pinimg.com/736x/49/c8/af/49c8af6978fb0c88dc1c9984a355de01.jpg" },
            { name: "Lori", imgSrc: "https://i.pinimg.com/736x/de/ae/ac/deaeaca51c41ad417b1fa60c2b6224c6.jpg" },
            { name: "Luan", imgSrc: "https://i.pinimg.com/1200x/71/72/e9/7172e9391dc9eae52480c0ce863d6b83.jpg" },
            { name: "Telespalla bob", imgSrc: "https://i.pinimg.com/1200x/67/3e/d2/673ed2c06d239d7d740d310538049d55.jpg" },
            { name: "Maya", imgSrc: "https://i.pinimg.com/736x/04/c2/1a/04c21a976e0e8eeaadc7eeefec3353ab.jpg" },
            { name: "Sonia", imgSrc: "https://i.pinimg.com/736x/eb/d4/f7/ebd4f76aaa1637a6bbe27a95268c540c.jpg" },
            { name: "Dipper", imgSrc: "https://i.pinimg.com/736x/dc/33/5c/dc335c6436eaa757a30969d52bf2f3cd.jpg" },
            { name: "Mabel", imgSrc: "https://i.pinimg.com/736x/f1/9b/b1/f19bb155ae63f6e551cae96b71f96f0b.jpg" },
            { name: "Stanley", imgSrc: "https://i.pinimg.com/736x/ca/db/59/cadb590c34fe1381e2e8dad55c3805c8.jpg" },
            { name: "Nonno max", imgSrc: "https://i.pinimg.com/1200x/75/1f/a7/751fa7bb45660391c9bae9bd88ebab55.jpg" },
            { name: "Pucca", imgSrc: "https://i.pinimg.com/736x/ab/d6/b1/abd6b1133bd848aedd2e63945be1f88c.jpg" },
            { name: "Orso Bianco", imgSrc: "https://i.pinimg.com/736x/b1/6a/0f/b16a0f0ffdd056b4c542d6ddf821195f.jpg" },
            { name: "Panda", imgSrc: "https://i.pinimg.com/1200x/cf/d2/85/cfd285a97021713f6f5cada516043233.jpg" },
            { name: "Pingu", imgSrc: "https://i.pinimg.com/736x/e2/d9/73/e2d9737e099300774dc58f45d8ba8433.jpg" },
            { name: "Raiden", imgSrc: "https://i.pinimg.com/736x/25/2a/87/252a87c80f1d6c19089392845df2ff4a.jpg" },
            { name: "Mucca", imgSrc: "https://i.pinimg.com/736x/60/b3/6d/60b36d7df673d10a61d4256988344680.jpg" },
            { name: "Rekkit", imgSrc: "https://i.pinimg.com/736x/58/92/df/5892df5f631fb347a9857883163d166d.jpg" },
            { name: "Corvina GO", imgSrc: "https://i.pinimg.com/1200x/6d/2d/7b/6d2d7b251a47303bcdc0e288da93dc1b.jpg" },
            { name: "Kai", imgSrc: "https://i.pinimg.com/1200x/81/00/21/810021d022d93dfa11b7ae8b72dc1dd0.jpg" },
            { name: "Cole", imgSrc: "https://i.pinimg.com/736x/7c/72/3d/7c723db51f3b7e8e15d121d1bbdc131b.jpg" },
            { name: "Lloyd", imgSrc: "https://i.pinimg.com/1200x/50/cc/4a/50cc4a4ced1f659d6eab83592c1dca39.jpg" },
            { name: "Wu", imgSrc: "https://i.pinimg.com/736x/83/09/a9/8309a943fa72f0e1af4ead6701e777b6.jpg" },
            { name: "Barbapapà", imgSrc: "https://i.pinimg.com/1200x/3a/b9/d1/3ab9d116849ceab6c48c0f77e59c3fd3.jpg" },
        ].sort((a, b) => a.name.localeCompare(b.name))
        .map((char, index) => ({ ...char, id: `pre${index + 1}` }));


        // --- FUNZIONI DI NAVIGAZIONE E UI ---
        const showScreen = (screenId) => {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            
            const isGameScreen = screenId === 'game-screen';
            chatToggleBtn.style.display = isGameScreen ? 'block' : 'none';
            tempLeaderboard.style.display = isGameScreen ? 'block' : 'none';
            if (!isGameScreen) {
                chatContainer.classList.remove('open');
            }
        };

        const showMessage = (text, duration = 3000) => {
            messageText.innerHTML = text; // Use innerHTML to support basic formatting
            
            const oldBtn = document.getElementById('host-continue-btn');
            if (oldBtn) oldBtn.remove();
            
            messageOverlay.style.display = 'flex';
            if (duration > 0) {
                setTimeout(() => messageOverlay.style.display = 'none', duration);
            }
        };

        const clearLocalTimers = () => {
            localTimers.forEach(timer => clearInterval(timer));
            localTimers = [];
        };
        
        // --- AUTENTICAZIONE E INIZIALIZZAZIONE ---
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUser = user;
            } else {
                signInAnonymously(auth).catch(error => console.error("Anonymous sign-in error:", error));
            }
        });
        
        // --- CONFIGURAZIONE ROSTER (HOST) ---
        const addCharacterToRoster = (char) => {
             const limit = selectedGameMode === 'classic' ? 120 : 200;
             if (localRoster.length >= limit) {
                 showMessage(`Hai raggiunto il limite di ${limit} personaggi per questa modalità.`, 2000);
                 return;
             }
             if(localRoster.some(c => c.id === char.id)) {
                 showMessage(`${char.name} è già stato aggiunto.`, 1500);
                 return;
             }
             localRoster.push(char);
             updateRosterUI();
             renderPredefinedRoster();
        };

        const handleAddCharacterFromCustom = () => {
            const name = charNameInput.value.trim();
            const imgSrc = charImgInput.value.trim();

            if (!name || !imgSrc) {
                showMessage("Inserisci nome e URL dell'immagine.", 2000);
                return;
            }

            try {
                new URL(imgSrc); 
            } catch (_) {
                showMessage("L'URL dell'immagine non è valido.", 2000);
                return;
            }

            const charId = Date.now().toString() + Math.random(); 
            addCharacterToRoster({ id: charId, name, imgSrc });
            
            charNameInput.value = '';
            charImgInput.value = '';
            charNameInput.focus();
        };

        const handleRemoveCharacter = (charId) => {
            localRoster = localRoster.filter(c => c.id !== charId);
            updateRosterUI();
            renderPredefinedRoster();
        };

        const updateRosterUI = () => {
            rosterList.innerHTML = '';
            localRoster.forEach(char => {
                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <img src="${char.imgSrc}" alt="${char.name}" onerror="this.style.display='none'">
                    <span>${char.name}</span>
                    <button data-char-id="${char.id}">Rimuovi</button>
                `;
                item.querySelector('button').addEventListener('click', () => handleRemoveCharacter(char.id));
                rosterList.appendChild(item);
            });
            
            const count = localRoster.length;
            if (selectedGameMode === 'classic') {
                charCounter.textContent = `Personaggi: ${count}/120`;
                createLobbyBtn.disabled = count < 4;
                createLobbyBtn.textContent = 'Crea Lobby (Min. 4)';
            } else { // tournament
                charCounter.textContent = `Personaggi: ${count}/200`;
                createLobbyBtn.disabled = count !== 200;
                 createLobbyBtn.textContent = 'Crea Lobby (200 Richiesti)';
            }
        };

        const renderPredefinedRoster = () => {
            predefinedGrid.innerHTML = '';
            predefinedRoster.forEach(char => {
                const isAdded = localRoster.some(c => c.id === char.id);
                const charEl = document.createElement('div');
                charEl.className = 'predefined-char';
                if(isAdded) charEl.classList.add('added');
                charEl.innerHTML = `<img src="${char.imgSrc}" alt="${char.name}">`;
                charEl.addEventListener('click', () => {
                    if(!isAdded) addCharacterToRoster(char);
                });
                predefinedGrid.appendChild(charEl);
            });
        };
        
        // --- LOGICA DELLA LOBBY ---
        const createGameFromRoster = async () => {
            const judgeName = playerNameInput.value.trim();
            if (!judgeName || !currentUser) {
                showMessage("Inserisci il tuo nome da giudice per continuare.", 2000);
                showScreen('home-screen');
                return;
            }
             if ((selectedGameMode === 'classic' && localRoster.length < 4) || (selectedGameMode === 'tournament' && localRoster.length !== 200)) {
                showMessage("Numero di personaggi non valido per la modalità selezionata.", 3000);
                return;
            }

            createLobbyBtn.disabled = true;
            const gameId = generateGameId();
            const gameRef = doc(db, "games", gameId);

            const initialGameState = {
                gameId: gameId,
                hostId: currentUser.uid,
                judges: [{ uid: currentUser.uid, name: judgeName, advantages: [], usedAdvantages: [] }],
                initialRoster: localRoster, 
                characters: [], 
                eliminated: [],
                gameState: "lobby",
                gameMode: selectedGameMode,
                message: `Benvenuto nella lobby! In attesa che l'host inizi la partita.`
            };

            if (selectedGameMode === 'tournament') {
                initialGameState.tournamentState = 'group_stage';
                initialGameState.currentGroupIndex = 0;
                initialGameState.groupWinners = [];
            }


            try {
                await setDoc(gameRef, initialGameState);
                joinLobby(gameId, judgeName);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Impossibile creare la partita. Riprova.", 3000);
                createLobbyBtn.disabled = false;
            }
        };

        const joinGame = async () => {
            const judgeName = playerNameInput.value.trim();
            const gameId = joinCodeInput.value.trim().toUpperCase();
            if (!judgeName || !gameId || !currentUser) {
                showMessage("Inserisci il tuo nome e il codice partita.", 2000);
                return;
            }

            joinGameBtn.disabled = true;
            const gameRef = doc(db, "games", gameId);
            
            try {
                 await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Partita non trovata!";

                    const gameData = gameDoc.data();
                    if (gameData.gameState !== 'lobby') throw "La partita è già iniziata!";

                    const judges = gameData.judges;
                    if (!judges.some(p => p.uid === currentUser.uid)) {
                        judges.push({ uid: currentUser.uid, name: judgeName, advantages: [], usedAdvantages: [] });
                    }
                    transaction.update(gameRef, { judges });
                });
                joinLobby(gameId, judgeName);
            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Impossibile unirsi: " + error, 3000);
                joinGameBtn.disabled = false;
            }
        };

        const joinLobby = (gameId, judgeName) => {
            currentGameId = gameId;
            localStorage.setItem('playerName', judgeName);
            showScreen('lobby-screen');
            listenToGameUpdates(gameId);
            listenToChatUpdates(gameId); 
        };

        const leaveGame = async () => {
             if (!currentGameId || !currentUser) return;
             
             const gameRef = doc(db, "games", currentGameId);
             try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) {
                    resetLocalState();
                    return;
                }
                let gameData = gameDoc.data();

                if (gameData.hostId === currentUser.uid) {
                    await deleteDoc(gameRef);
                } else {
                    let judges = gameData.judges.filter(p => p.uid !== currentUser.uid);
                    await updateDoc(gameRef, { judges });
                }
             } catch (error) {
                 console.error("Error leaving game: ", error);
             } finally {
                 resetLocalState();
             }
        };

        const listenToGameUpdates = (gameId) => {
            const gameRef = doc(db, "games", gameId);
            if (unsubFromGame) unsubFromGame();

            unsubFromGame = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("La partita è stata chiusa dall'host.", 4000);
                    resetLocalState();
                    return;
                }
                const gameData = doc.data();
                const isHost = currentUser && currentUser.uid === gameData.hostId;

                // Host-specific real-time logic
                if (isHost && !isProcessingDuel) {
                    if (gameData.gameState === 'voting') {
                        const votesCount = Object.keys(gameData.currentDuel.votes || {}).length;
                        const judgesCount = gameData.judges.length;
                        if (votesCount >= judgesCount) {
                            clearTimeout(duelResolutionTimer);
                            resolveDuel();
                            return; 
                        }
                    }
                }
                
                updateUI(gameData);
            });
        };

        const updateUI = (gameData) => {
            const isHost = currentUser && currentUser.uid === gameData.hostId;

            if (gameData.gameState === 'lobby') {
                showScreen('lobby-screen');
                gameCodeDisplay.textContent = gameData.gameId;
                playerList.innerHTML = '';
                gameData.judges.forEach(judge => {
                    const li = document.createElement('li');
                    li.textContent = judge.name;
                    if (judge.uid === gameData.hostId) {
                        const hostTag = document.createElement('span');
                        hostTag.className = 'host-tag';
                        hostTag.textContent = '(Host)';
                        li.appendChild(hostTag);
                    }
                    playerList.appendChild(li);
                });
                
                const advantagesContainer = document.getElementById('advantages-selection-container');
                if (gameData.gameMode === 'tournament') {
                    advantagesContainer.style.display = 'none';
                } else {
                    advantagesContainer.style.display = 'block';
                    renderAdvantagesSelection(gameData);
                }

                startGameBtn.style.display = isHost ? 'block' : 'none';
                leaveLobbyBtn.textContent = isHost ? 'Chiudi Lobby' : 'Esci dalla Lobby';
            }
            
            const isGameScreenActive = document.getElementById('game-screen').classList.contains('active');
            
            if (isGameScreenActive) {
                updateTemporaryLeaderboard(gameData);
                renderPlayerAdvantages(gameData, gameData.gameState === 'voting');
                renderGroupWinnersSidebar(gameData);
            }

            
            switch(gameData.gameState) {
                case 'starting':
                    showScreen('game-screen');
                    showMessage(gameData.message, 3000);
                    createArena(gameData);
                    break;
                case 'intermission':
                    showScreen('game-screen');
                    showMessage(gameData.message, 0); // Permanent message
                    updateArena(gameData);
                    
                    const oldBtn = document.getElementById('host-continue-btn');
                    if (oldBtn) oldBtn.remove();

                    if (isHost) {
                        const continueBtn = document.createElement('button');
                        continueBtn.id = 'host-continue-btn';
                        continueBtn.textContent = 'Prosegui';
                        continueBtn.className = 'btn-primary';
                        continueBtn.style.marginTop = '20px';
                        continueBtn.addEventListener('click', () => {
                            continueBtn.disabled = true;
                            startNextTournamentRound();
                        });
                        messageOverlayContent.appendChild(continueBtn);
                    }
                    break;
                case 'selection_phase':
                    showScreen('game-screen');
                    showMessage(gameData.message, 0);
                    updateArena(gameData);
                    displaySelectionAnimation(gameData);
                    break;
                case 'voting':
                    showScreen('game-screen');
                    updateArena(gameData);
                    showMessage(gameData.message, 0);
                    showVoteModal(gameData);
                    break;
                case 'shield_choice_pending':
                     showScreen('game-screen');
                     updateArena(gameData);
                     showMessage(gameData.message, 0);
                     if (currentUser.uid === gameData.currentDuel.shieldChooser) {
                         showShieldChoiceModal(gameData);
                     }
                     break;
                case 'targeted_shot_pending':
                    showMessage(gameData.message, 0);
                    voteModal.style.display = 'none'; // Ensure vote modal is hidden
                    if (currentUser.uid === gameData.currentDuel.targetedShotChooser) {
                        showTargetedShotModal(gameData);
                    }
                    break;
                case 'reveal_winner':
                case 'reveal_loser':
                case 'round_end':
                case 'round_end_after_choice':
                      showScreen('game-screen');
                      showMessage(gameData.message, 4000);
                      updateArena(gameData);
                      handleRevealSequence(gameData);
                      clearLocalTimers();
                      break;
                case 'finished':
                    voteModal.style.display = 'none';
                    showScreen('results-screen');
                    if (unsubFromGame) unsubFromGame();
                    unsubFromGame = null;
                    displayResults(gameData);
                    rematchBtn.style.display = isHost ? 'block' : 'none';
                    break;
            }
        };

        const handleStartGame = async () => {
            if (!currentGameId || !currentUser) return;
            const gameRef = doc(db, "games", currentGameId);
            const gameDoc = await getDoc(gameRef);
            if (!gameDoc.exists()) return;
            
            const gameData = gameDoc.data();
            const judgesWithResetAdvantages = gameData.judges.map(j => ({ ...j, usedAdvantages: [] }));
            const shuffledCharacters = shuffleArray([...gameData.initialRoster]);

            if (gameData.gameMode === 'tournament') {
                const groups = [];
                for (let i = 0; i < 10; i++) {
                    groups.push(shuffledCharacters.slice(i * 20, (i + 1) * 20));
                }
                const firstGroup = groups[0].map(char => ({...char, territories: [], eliminations: 0 }));
                 await updateDoc(gameRef, {
                    gameState: 'starting',
                    characters: firstGroup,
                    judges: judgesWithResetAdvantages,
                    eliminated: [],
                    tournamentGroups: JSON.stringify(groups), // Convert to string for Firestore
                    message: 'Torneo: Inizia il Gruppo 1!'
                });

            } else { // Classic mode
                shuffledCharacters.forEach((char, index) => {
                    char.territories = [index];
                    char.eliminations = 0; 
                });
                 await updateDoc(gameRef, {
                    gameState: 'starting',
                    characters: shuffledCharacters,
                    judges: judgesWithResetAdvantages,
                    eliminated: [],
                    message: 'La partita sta per iniziare...'
                });
            }
            
            setTimeout(() => {
                if (currentUser.uid === gameData.hostId) {
                    startNextTournamentRound(); // This function now handles both modes
                }
            }, 3000);
        };
        
        // --- LOGICA DI GIOCO ---
        let isLogicRunning = false;
        
        const startNextTournamentRound = async () => {
            if (isLogicRunning || !currentGameId) return;
            isLogicRunning = true;

             const gameRef = doc(db, "games", currentGameId);
             const gameDoc = await getDoc(gameRef);
             if (!gameDoc.exists()) {
                isLogicRunning = false;
                return;
             }
             let gameData = gameDoc.data();
             
             let charactersForNextRound = [];
             let message = '';
             let nextGameState = 'starting';

             if (gameData.gameMode === 'tournament') {
                 if (gameData.tournamentState === 'group_stage') {
                    const allGroups = JSON.parse(gameData.tournamentGroups);
                    if (gameData.currentGroupIndex >= allGroups.length) { // All groups finished, move to finals
                        charactersForNextRound = shuffleArray(gameData.groupWinners);
                        gameData.tournamentState = 'finals';
                        message = 'Iniziano le Finali del Torneo!';
                    } else { // Next group
                        charactersForNextRound = shuffleArray(allGroups[gameData.currentGroupIndex]);
                        message = `Inizia il Gruppo ${gameData.currentGroupIndex + 1}!`;
                    }
                 } else { // Finals already started
                    executeRoundTurn(); // Just continue the final match
                    return; // exit function early
                 }
             } else { // Classic mode
                 executeRoundTurn();
                 return; // exit function early
             }

             charactersForNextRound.forEach((char, index) => {
                 char.territories = [index];
                 char.eliminations = 0; // Reset for the new round
             });

            await updateDoc(gameRef, {
                characters: charactersForNextRound,
                eliminated: [],
                currentDuel: null,
                gameState: 'starting',
                tournamentState: gameData.tournamentState,
                message: message
            });

            setTimeout(() => {
                isLogicRunning = false;
                executeRoundTurn();
            }, 3000);
        };


        const executeRoundTurn = async () => {
            if (isLogicRunning || !currentGameId) return;
            isLogicRunning = true;
            try {
                const gameRef = doc(db, "games", currentGameId);
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) { throw "Game not found"; }
                let gameData = gameDoc.data();

                let activeCharacters = gameData.characters.filter(c => c.territories.length > 0);
                let attacker, defender;
                let turnData = {};

                if (gameData.nextAttackerId && gameData.nextDefenderId) {
                    attacker = activeCharacters.find(c => c.id === gameData.nextAttackerId);
                    defender = activeCharacters.find(c => c.id === gameData.nextDefenderId);
                    turnData = { nextAttackerId: null, nextDefenderId: null };
                } else {
                    const shuffledAttackers = shuffleArray([...activeCharacters]);
                    for (const potentialAttacker of shuffledAttackers) {
                        const potentialNeighbors = getValidNeighbors(potentialAttacker, gameData);
                        if (potentialNeighbors.length > 0) {
                            attacker = potentialAttacker;
                            defender = potentialNeighbors[Math.floor(Math.random() * potentialNeighbors.length)].owner;
                            break;
                        }
                    }
                }

                if (!attacker || !defender) {
                    await updateDoc(gameRef, { message: "Nessuna mossa valida! Si salta il turno.", gameState: 'round_end' });
                    setTimeout(() => { if (currentUser.uid === gameData.hostId) executeRoundTurn(); }, 4000);
                    isLogicRunning = false;
                    return;
                }

                await updateDoc(gameRef, {
                    ...turnData,
                    gameState: 'selection_phase',
                    currentDuel: {
                        attackerId: attacker.id,
                        defenderId: defender.id,
                        usedAdvantages: {},
                        votes: {},
                    },
                    message: `${attacker.name} si prepara ad attaccare!`
                });

                setTimeout(async () => {
                    if (!currentGameId) return;
                    const freshGameDoc = await getDoc(doc(db, "games", currentGameId));
                    if (!freshGameDoc.exists()) return;
                    const freshGameData = freshGameDoc.data();
                    const currentAttacker = freshGameData.characters.find(c => c.id === freshGameData.currentDuel.attackerId);
                    const currentDefender = freshGameData.characters.find(c => c.id === freshGameData.currentDuel.defenderId);
                    if(!currentAttacker || !currentDefender) return;

                    await updateDoc(gameRef, {
                        'currentDuel.voteDeadline': Date.now() + 15000,
                        gameState: 'voting',
                        message: `${currentAttacker.name} attacca ${currentDefender.name}!`
                    });
                    startVoteTimerOnHost(gameData.hostId);
                }, 6000);

            } catch (error) {
                console.error("Error in turn execution:", error);
            } finally {
                isLogicRunning = false;
            }
        };

        const displaySelectionAnimation = (gameData) => {
            clearInterval(animationInterval);
            document.querySelectorAll('.roulette-active, .target-highlighted, .attacker-selected').forEach(el => el.classList.remove('roulette-active', 'target-highlighted', 'attacker-selected'));
            
            if (gameData.gameState !== 'selection_phase' || !gameData.currentDuel) return;

            const { attackerId } = gameData.currentDuel;
            if (!attackerId) return;

            const activeCharacters = gameData.characters.filter(c => c.territories.length > 0);

            
            let lastHighlight = null;
            let rouletteCount = 0;
            animationInterval = setInterval(() => {
                if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                const randomChar = activeCharacters[Math.floor(Math.random() * activeCharacters.length)];
                const cell = arena.querySelector(`[data-owner-id='${randomChar.id}']`);
                if (cell) { 
                    cell.classList.add('roulette-active');
                    lastHighlight = cell;
                }
                rouletteCount++;
                if(rouletteCount > 18) { // ~2.7 seconds
                    clearInterval(animationInterval);
                    if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                    
                    
                    const attackerCell = arena.querySelector(`[data-owner-id='${attackerId}']`);
                    if (attackerCell) attackerCell.classList.add('attacker-selected');

                    
                    const attacker = activeCharacters.find(c => c.id === attackerId);
                    if (!attacker) return;
                    const neighbors = getValidNeighbors(attacker, gameData);
                    if (neighbors.length > 0) {
                        let lastTargetHighlight = null;
                        let targetCount = 0;
                        animationInterval = setInterval(() => {
                            if (lastTargetHighlight) lastTargetHighlight.classList.remove('target-highlighted');
                            if (neighbors.length === 1) {
                                const targetCell = arena.querySelector(`[data-index='${neighbors[0].cellIndex}']`);
                                if (targetCell) targetCell.classList.add('target-highlighted');
                            } else {
                                const randomTarget = neighbors[Math.floor(Math.random() * neighbors.length)];
                                const targetCell = arena.querySelector(`[data-index='${randomTarget.cellIndex}']`);
                                if (targetCell) { 
                                    targetCell.classList.add('target-highlighted');
                                    lastTargetHighlight = targetCell;
                                }
                            }
                            targetCount++;
                            if(targetCount > 18) { // ~2.7 seconds
                                clearInterval(animationInterval);
                                if(lastTargetHighlight) lastTargetHighlight.classList.remove('target-highlighted');
                            }
                        }, 150);
                    }
                }
            }, 150);
        };

        const startVoteTimerOnHost = (hostId) => {
            if (currentUser.uid !== hostId) return;
            clearTimeout(duelResolutionTimer);
            duelResolutionTimer = setTimeout(resolveDuel, 16000);
        };
        
        const castVote = async (winnerId) => {
            if (!currentGameId || !currentUser) return;
            document.querySelectorAll('.vote-btn').forEach(b => b.disabled = true);
            
            const gameRef = doc(db, "games", currentGameId);
            const votePath = `currentDuel.votes.${currentUser.uid}`;
            await updateDoc(gameRef, { [votePath]: winnerId });
        };
        
        const resolveDuel = async () => {
            if (!currentGameId || isProcessingDuel) return;
            isProcessingDuel = true;
            const gameRef = doc(db, "games", currentGameId);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Game not found.";
                    let gameData = gameDoc.data();

                    if (gameData.gameState !== 'voting') return;

                    let { attackerId, defenderId, votes, usedAdvantages = {} } = gameData.currentDuel;
                    
                    if (gameData.gameMode === 'tournament') {
                        usedAdvantages = {}; // Ignora tutti i vantaggi in modalità torneo
                    }

                    const advantagesPlayed = Object.values(usedAdvantages).map(adv => adv.key);

                    if (advantagesPlayed.includes('forced_reversal')) {
                        [attackerId, defenderId] = [defenderId, attackerId];
                    }

                    let winnerId, loserId;
                    let isDraw = false;
                    let message = "";
                    let voteCounts = { [attackerId]: 0, [defenderId]: 0 };

                    if (advantagesPlayed.includes('calculated_chaos')) {
                        winnerId = Math.random() < 0.5 ? attackerId : defenderId;
                        loserId = winnerId === attackerId ? defenderId : attackerId;
                        message = "Il Caos Calcolato ha deciso il vincitore!";
                    } else if (advantagesPlayed.includes('cancel_votes')) {
                        const deciderId = Object.keys(usedAdvantages).find(uid => usedAdvantages[uid].key === 'cancel_votes');
                        const finalVote = votes[deciderId];
                        if (finalVote) {
                            winnerId = finalVote;
                            loserId = winnerId === attackerId ? defenderId : attackerId;
                        } else {
                            [winnerId, loserId] = [attackerId, defenderId];
                        }
                        message = "Un Voto Decisivo ha scelto il vincitore!";
                    } else {
                        for (const voterId in (votes || {})) {
                            const vote = votes[voterId];
                            let voteValue = 1;
                            if (usedAdvantages[voterId]?.key === 'extra_vote') {
                                voteValue = 2;
                            }
                            if (voteCounts[vote] !== undefined) voteCounts[vote] += voteValue;
                        }

                        if (voteCounts[attackerId] > voteCounts[defenderId]) [winnerId, loserId] = [attackerId, defenderId];
                        else if (voteCounts[defenderId] > voteCounts[attackerId]) [winnerId, loserId] = [defenderId, attackerId];
                        else {
                            const lastWordUserId = Object.keys(usedAdvantages).find(uid => usedAdvantages[uid].key === 'last_word');
                            if (lastWordUserId && votes[lastWordUserId]) {
                                winnerId = votes[lastWordUserId];
                                loserId = winnerId === attackerId ? defenderId : attackerId;
                            } else {
                                winnerId = Math.random() < 0.5 ? attackerId : defenderId;
                                loserId = winnerId === attackerId ? defenderId : attackerId;
                            }
                        }
                        if (advantagesPlayed.includes('plot_twist')) [winnerId, loserId] = [loserId, winnerId];
                    }
                    
                    const bodyguardInfo = Object.values(usedAdvantages).find(adv => adv.key === 'bodyguard');
                    if (bodyguardInfo && bodyguardInfo.target === loserId) {
                        isDraw = true;
                        const savedChar = gameData.characters.find(c => c.id === loserId);
                        message = `${savedChar.name} è stato salvato dalla sua Guardia del Corpo! Il duello è un pareggio.`;
                    }

                    const destinyShieldUserId = Object.keys(usedAdvantages).find(uid => usedAdvantages[uid].key === 'destiny_shield');
                    if (!isDraw && destinyShieldUserId && votes[destinyShieldUserId] === loserId) {
                        transaction.update(gameRef, {
                            gameState: 'shield_choice_pending',
                            'currentDuel.shieldChooser': destinyShieldUserId,
                            'currentDuel.winnerId': winnerId,
                            'currentDuel.loserId': loserId,
                            'currentDuel.voteCounts': voteCounts,
                            message: `Scudo del Destino attivato! In attesa della scelta...`
                        });
                        return;
                    }

                    const targetedShotUserId = Object.keys(usedAdvantages).find(uid => usedAdvantages[uid].key === 'next_attacker_choice');
                    if (!isDraw && targetedShotUserId) {
                        const winnerChar = gameData.characters.find(c => c.id === winnerId);
                        const validTargets = getValidNeighbors(winnerChar, gameData);

                        if (validTargets.length > 0) {
                             let characters = [...gameData.characters];
                             let eliminated = gameData.eliminated || [];
                             const winnerIndex = characters.findIndex(c => c.id === winnerId);
                             const loserIndex = characters.findIndex(c => c.id === loserId);
                             if (winnerIndex > -1 && loserIndex > -1) {
                                 characters[winnerIndex].eliminations = (characters[winnerIndex].eliminations || 0) + 1;
                                 characters[winnerIndex].territories.push(...characters[loserIndex].territories);
                                 characters[loserIndex].territories = [];
                                 eliminated.push({ ...characters[loserIndex], eliminatedBy: characters[winnerIndex].name });
                                 if (!message) message = `${characters[winnerIndex].name} ha sconfitto ${characters[loserIndex].name}!`;
                             }

                            transaction.update(gameRef, {
                                characters,
                                eliminated,
                                'currentDuel.winnerId': winnerId,
                                'currentDuel.loserId': loserId,
                                'currentDuel.voteCounts': voteCounts,
                                'currentDuel.targetedShotChooser': targetedShotUserId,
                                gameState: 'targeted_shot_pending',
                                message: `Tiro Mirato! ${gameData.judges.find(j => j.uid === targetedShotUserId)?.name} sceglie il bersaglio.`
                            });
                            return; 
                        }
                    }

                    let characters = [...gameData.characters];
                    let eliminated = gameData.eliminated || [];
                    
                    if (!isDraw) {
                        const winnerIndex = characters.findIndex(c => c.id === winnerId);
                        const loserIndex = characters.findIndex(c => c.id === loserId);
                        if (winnerIndex > -1 && loserIndex > -1) {
                            characters[winnerIndex].eliminations = (characters[winnerIndex].eliminations || 0) + 1;
                            characters[winnerIndex].territories.push(...characters[loserIndex].territories);
                            characters[loserIndex].territories = [];
                            eliminated.push({ ...characters[loserIndex], eliminatedBy: characters[winnerIndex].name });
                            if (!message) message = `${characters[winnerIndex].name} ha sconfitto ${characters[loserIndex].name}!`;
                        }
                    }
                    
                    const activeCharacters = characters.filter(c => c.territories.length > 0);
                    const finalUpdate = {
                        characters,
                        eliminated,
                        message,
                        'currentDuel.winnerId': winnerId,
                        'currentDuel.loserId': loserId,
                        'currentDuel.voteCounts': voteCounts,
                    };
                    
                    if (activeCharacters.length <= 1) {
                        if (gameData.gameMode === 'tournament' && gameData.tournamentState === 'group_stage') {
                            const winner = activeCharacters[0];
                            finalUpdate.groupWinners = [...(gameData.groupWinners || []), winner];
                            finalUpdate.currentGroupIndex = gameData.currentGroupIndex + 1;
                            finalUpdate.gameState = 'intermission';
                            finalUpdate.message = `<h3>${winner.name} vince il Gruppo ${gameData.currentGroupIndex + 1}!</h3><p>In attesa che l'host prosegua...</p>`;

                        } else {
                            finalUpdate.gameState = 'finished';
                            finalUpdate.message = `La partita è finita! Il vincitore è ${activeCharacters[0]?.name || 'Nessuno'}!`;
                        }
                    } else {
                        finalUpdate.gameState = 'reveal_winner';
                    }
                    transaction.update(gameRef, finalUpdate);
                });
            } catch(error) {
                console.error("Error resolving duel:", error);
            } finally {
                isProcessingDuel = false;
            }
        };
        
        const handleRevealSequence = async (gameData) => {
            const isHost = currentUser.uid === gameData.hostId;
            const { winnerId, loserId, voteCounts } = gameData.currentDuel;
            if (!winnerId || !loserId) return;

            const allChars = [...gameData.characters, ...gameData.eliminated];
            const winner = allChars.find(c => c.id === winnerId);
            const loser = allChars.find(c => c.id === loserId);
            if(!winner || !loser) return;
            
            if (gameData.gameState === 'reveal_winner') {
                voteModal.style.display = 'flex';
                voteView.style.display = 'none';
                revealView.style.display = 'block';
                winnerRevealText.textContent = `${winner.name} con ${voteCounts[winnerId] || 0} voti`;
                winnerReveal.style.display = 'block';
                loserReveal.style.display = 'none';

                if (isHost) {
                    setTimeout(() => {
                        updateDoc(doc(db, "games", currentGameId), { gameState: 'reveal_loser' });
                    }, 2500);
                }
            } else if (gameData.gameState === 'reveal_loser') {
                voteModal.style.display = 'flex';
                loserRevealText.textContent = `${loser.name} con ${voteCounts[loserId] || 0} voti`;
                loserReveal.style.display = 'block';

                if (isHost) {
                    setTimeout(() => {
                        updateDoc(doc(db, "games", currentGameId), { gameState: 'round_end' });
                    }, 2500);
                }
            } else if (gameData.gameState === 'round_end' || gameData.gameState === 'round_end_after_choice') {
                voteModal.style.display = 'none';
                if (isHost) {
                    setTimeout(() => {
                        if (gameData.currentDuel?.targetedShotChooser) {
                             const chooserStillInGame = gameData.judges.some(j => j.uid === gameData.currentDuel.targetedShotChooser);
                             if (chooserStillInGame) {
                                 updateDoc(doc(db, "games", currentGameId), { gameState: 'targeted_shot_pending' });
                             } else {
                                 executeRoundTurn(); 
                             }
                        } else {
                            executeRoundTurn();
                        }
                    }, 2000);
                }
            }
        };

        // --- FUNZIONI DI VISUALIZZAZIONE GIOCO ---
        const createArena = (gameData) => {
            arena.innerHTML = '';
             const gridSize = gameData.characters.length;
             const ratio = window.innerWidth / window.innerHeight;
             const cols = Math.ceil(Math.sqrt(gridSize * ratio));
             const rows = Math.ceil(gridSize / cols);
            
            arena.style.gridTemplateColumns = `repeat(${cols}, 100px)`;
            const grid = new Array(cols * rows).fill(null);
            
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);
            activeChars.forEach(char => {
                char.territories.forEach(index => { grid[index] = char; });
            });

            for(let i = 0; i < grid.length; i++) {
                const character = grid[i];
                const cell = document.createElement('div');
                cell.className = 'character-cell';
                cell.dataset.index = i;
                if (character) {
                    cell.dataset.ownerId = character.id;
                    cell.style.border = `3px solid ${character.color || getRandomColor()}`;
                    cell.innerHTML = `
                        <img src="${character.imgSrc}" alt="${character.name}" onerror="this.src='https://placehold.co/100x100/1a1a1a/444?text=X'">
                        <div class="character-name">${character.name}</div>
                    `;
                } else {
                    cell.style.visibility = 'hidden';
                }
                arena.appendChild(cell);
            }
            setupPanzoom();
        };

        const updateArena = (gameData) => {
            document.querySelectorAll('.attacker-selected, .target-highlighted').forEach(el => el.classList.remove('attacker-selected', 'target-highlighted'));
            
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);

            arena.querySelectorAll('.character-cell').forEach(cell => {
                const owner = activeChars.find(c => c.territories.includes(parseInt(cell.dataset.index)));
                if (owner) {
                    if (cell.dataset.ownerId !== owner.id) {
                        cell.dataset.ownerId = owner.id;
                        cell.style.borderColor = owner.color || getRandomColor();
                        cell.querySelector('img').src = owner.imgSrc;
                        cell.querySelector('.character-name').textContent = owner.name;
                    }
                    cell.style.opacity = 1;
                } else {
                    cell.style.opacity = 0.3;
                }
            });

            if (gameData.currentDuel?.attackerId) {
                const attackerCell = arena.querySelector(`[data-owner-id='${gameData.currentDuel.attackerId}']`);
                if(attackerCell) attackerCell.classList.add('attacker-selected');
            }
        };

        const updateTemporaryLeaderboard = (gameData) => {
            if (!gameData.characters) return;
             let leaderboardTitle = "Classifica";
             if(gameData.gameMode === 'tournament') {
                 if(gameData.tournamentState === 'group_stage') {
                     leaderboardTitle = `GRUPPO ${gameData.currentGroupIndex + 1}`;
                 } else {
                     leaderboardTitle = 'FINALE';
                 }
             }
             tempLeaderboard.querySelector('h3').textContent = leaderboardTitle;


            const activeCharacters = gameData.characters
                .filter(c => c.territories.length > 0)
                .sort((a, b) => b.territories.length - a.territories.length);
            
            const eliminatedList = [...(gameData.eliminated || [])].reverse();
            
            tempLeaderboardList.innerHTML = ''; 
            let rank = 1;

            // Display active players first, ranked by territory count
            activeCharacters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'leaderboard-item';
                li.innerHTML = `
                    <span class="leaderboard-rank">${rank++}</span>
                    <img src="${char.imgSrc}" class="leaderboard-img" alt="${char.name}">
                    <span class="leaderboard-name">${char.name} (${char.territories.length})</span>
                `;
                tempLeaderboardList.appendChild(li);
            });

            // Display eliminated players at the bottom
            eliminatedList.forEach(char => {
                const li = document.createElement('li');
                li.className = 'leaderboard-item';
                li.style.opacity = '0.5';
                li.innerHTML = `
                    <span class="leaderboard-rank">${rank++}</span>
                    <img src="${char.imgSrc}" class="leaderboard-img" alt="${char.name}">
                    <span class="leaderboard-name" style="text-decoration: line-through;">${char.name}</span>
                `;
                tempLeaderboardList.appendChild(li);
            });
        };
        
        const renderGroupWinnersSidebar = (gameData) => {
            const sidebar = document.getElementById('group-winners-sidebar');
            const list = document.getElementById('group-winners-list');

            if (gameData.gameMode !== 'tournament' || !gameData.groupWinners || gameData.groupWinners.length === 0) {
                sidebar.style.display = 'none';
                return;
            }

            sidebar.style.display = 'flex';
            list.innerHTML = '';

            gameData.groupWinners.forEach((winner, index) => {
                const winnerEl = document.createElement('div');
                winnerEl.className = 'winner-item';
                winnerEl.innerHTML = `
                    <img src="${winner.imgSrc}" alt="${winner.name}" title="${winner.name}">
                    <span>G${index + 1}</span>
                `;
                list.appendChild(winnerEl);
            });
        };

        const showVoteModal = (gameData) => {
             const { attackerId, defenderId, votes, voteDeadline, usedAdvantages = {} } = gameData.currentDuel;
             if (!attackerId || !defenderId) return;
             
             const allChars = [...gameData.characters, ...gameData.eliminated];
             const attacker = allChars.find(c => c.id === attackerId);
             const defender = allChars.find(c => c.id === defenderId);

             if (!attacker || !defender) return;
             
             attackerInfo.innerHTML = `<img src="${attacker.imgSrc}"><h3>${attacker.name}</h3><p class="vote-count-display"></p>`;
             defenderInfo.innerHTML = `<img src="${defender.imgSrc}"><h3>${defender.name}</h3><p class="vote-count-display"></p>`;
             voteActions.innerHTML = `
                 <button class="btn-primary vote-btn" data-winner-id="${attackerId}">VOTA ${attacker.name}</button>
                 <button class="btn-primary vote-btn" data-winner-id="${defenderId}">VOTA ${defender.name}</button>
             `;

            // Revelation advantage logic
            const myAdvantageInfo = usedAdvantages[currentUser.uid];
            if (myAdvantageInfo?.key === 'revelation') {
                const voteCounts = { [attackerId]: 0, [defenderId]: 0 };
                for (const voterId in (votes || {})) {
                    const vote = votes[voterId];
                    let voteValue = 1;
                    if (usedAdvantages[voterId]?.key === 'extra_vote') {
                        voteValue = 2;
                    }
                    if (voteCounts[vote] !== undefined) voteCounts[vote] += voteValue;
                }
                attackerInfo.querySelector('.vote-count-display').textContent = `${voteCounts[attackerId]} voti`;
                defenderInfo.querySelector('.vote-count-display').textContent = `${voteCounts[defenderId]} voti`;
            }
             
             const hasVoted = votes && votes[currentUser.uid];
             document.querySelectorAll('.vote-btn').forEach(btn => {
                 if(hasVoted) btn.disabled = true;
                 btn.addEventListener('click', () => castVote(btn.dataset.winnerId));
             });
             
             renderPlayerAdvantages(gameData, true);

             voteModal.style.display = 'flex';
             voteView.style.display = 'block';
             revealView.style.display = 'none';
             
             clearLocalTimers();
             const timerInterval = setInterval(() => {
                 const timeLeft = Math.max(0, Math.ceil(((voteDeadline || 0) - Date.now()) / 1000));
                 voteTimer.textContent = timeLeft;
                 if (timeLeft <= 0) clearInterval(timerInterval);
             }, 1000);
             localTimers.push(timerInterval);
        };
        
        const displayResults = (gameData) => {
            const winner = gameData.characters.find(c => c.territories.length > 0);
            winnerAnnouncement.textContent = winner ? `IL VINCITORE È ${winner.name}!` : "LA PARTITA È FINITA!";

            const finalRankings = winner ? [winner, ...[...gameData.eliminated].reverse()] : [...gameData.eliminated].reverse();
            
            finalRankingTableBody.innerHTML = '';
            finalRankings.forEach((char, i) => {
                finalRankingTableBody.innerHTML += `
                    <tr>
                        <td>${i + 1}</td>
                        <td><img src="${char.imgSrc}" class="rank-img">${char.name}</td>
                        <td>${char.eliminations || 0}</td>
                    </tr>`;
            });
        };

        const handleRematch = async () => {
             if (!currentGameId || !currentUser) return;
             const gameRef = doc(db, "games", currentGameId);
             
             try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) return;
                const gameData = gameDoc.data();

                const resetJudges = gameData.judges.map(j => ({ 
                    ...j, 
                    usedAdvantages: [], 
                }));
                
                const updateData = {
                    gameState: 'lobby',
                    characters: gameData.initialRoster, 
                    eliminated: [],
                    currentDuel: null,
                    judges: resetJudges,
                    nextAttackerId: null,
                    nextDefenderId: null,
                };
                
                 if (gameData.gameMode === 'tournament') {
                     updateData.tournamentState = 'group_stage';
                     updateData.currentGroupIndex = 0;
                     updateData.groupWinners = [];
                 }

                await updateDoc(gameRef, updateData);
                listenToGameUpdates(currentGameId);
             } catch (error) {
                 console.error("Error on rematch:", error);
             }
        };

        // --- CHAT FUNCTIONS ---
        const listenToChatUpdates = (gameId) => {
            if (unsubFromChat) unsubFromChat();
            const chatRef = collection(db, "games", gameId, "chat");
            const q = query(chatRef, orderBy("timestamp"));

            unsubFromChat = onSnapshot(q, (snapshot) => {
                chatMessages.innerHTML = '';
                snapshot.forEach(doc => {
                    const msg = doc.data();
                    const msgDiv = document.createElement('div');
                    msgDiv.classList.add('chat-message');
                    msgDiv.classList.add(msg.uid === currentUser.uid ? 'sent' : 'received');
                    
                    let senderHTML = '';
                    if (msg.uid !== currentUser.uid) {
                        senderHTML = `<div class="chat-sender">${msg.senderName}</div>`;
                    }
                    
                    msgDiv.innerHTML = `${senderHTML}<div>${msg.text}</div>`;
                    chatMessages.appendChild(msgDiv);
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        };

        const sendChatMessage = async () => {
            const text = chatInput.value.trim();
            if (text === '' || !currentGameId || !currentUser) return;

            const name = localStorage.getItem('playerName') || 'Giudice';
            const chatRef = collection(db, "games", currentGameId, "chat");
            
            try {
                await addDoc(chatRef, {
                    uid: currentUser.uid,
                    senderName: name,
                    text: text,
                    timestamp: serverTimestamp()
                });
                chatInput.value = '';
            } catch (error) {
                console.error("Error sending message:", error);
                showMessage("Impossibile inviare il messaggio.", 2000);
            }
        };


        // --- FUNZIONI DI UTILITÀ ---
        const resetLocalState = () => {
             if (unsubFromGame) unsubFromGame();
             if (unsubFromChat) unsubFromChat();
             unsubFromGame = null;
             unsubFromChat = null;
             currentGameId = null;
             isLogicRunning = false;
             isProcessingDuel = false;
             localRoster = [];
             clearLocalTimers();
             showScreen('home-screen');
             joinGameBtn.disabled = false;
             createLobbyBtn.disabled = false;
        };

        const generateGameId = () => Math.random().toString(36).substring(2, 7).toUpperCase();
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        const getRandomColor = () => `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;

        const getValidNeighbors = (character, gameData) => {
            const neighbors = [];
            const gridSize = gameData.characters.length;
            const ratio = window.innerWidth / window.innerHeight;
            const cols = Math.ceil(Math.sqrt(gridSize * ratio));
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);

            character.territories.forEach(index => {
                const x = index % cols;
                const y = Math.floor(index / cols);
                [{ dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }].forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    const neighborIndex = newY * cols + newX;
                    const owner = activeChars.find(c => c.territories.includes(neighborIndex));
                    if (owner && owner.id !== character.id && !neighbors.some(n => n.owner.id === owner.id)) {
                        neighbors.push({ owner, cellIndex: neighborIndex });
                    }
                });
            });
            return neighbors;
        };
        
        const setupPanzoom = () => {
             if (panzoom) panzoom.destroy();
             panzoom = Panzoom(arena, { maxScale: 5, minScale: 0.2, canvas: true });
             arenaContainer.addEventListener('wheel', panzoom.zoomWithWheel);
             setTimeout(() => {
                 const containerRect = arenaContainer.getBoundingClientRect();
                 const elemRect = arena.getBoundingClientRect();
                 if (elemRect.width === 0) return;
                 const scale = Math.min(containerRect.width / elemRect.width, containerRect.height / elemRect.height) * 0.95;
                 panzoom.zoom(scale, { animate: true });
             }, 250);
        };
        
        // --- ADVANTAGE FUNCTIONS ---
        const renderAdvantagesSelection = (gameData) => {
            advantagesGrid.innerHTML = '';
            const me = gameData.judges.find(j => j.uid === currentUser.uid);
            if (!me) return;

            const myAdvantages = me.advantages || [];

            for (const key in advantages) {
                const adv = advantages[key];
                const item = document.createElement('div');
                item.className = 'advantage-item';
                item.dataset.advantageKey = key;
                item.innerHTML = `
                    <span>${adv.emoji}</span>
                    <span class="tooltip">${adv.name}: ${adv.description}</span>
                `;

                if (myAdvantages.includes(key)) {
                    item.classList.add('selected');
                }

                const canSelectMore = myAdvantages.length < 2;
                if (!canSelectMore && !myAdvantages.includes(key)) {
                    item.classList.add('disabled');
                }

                item.addEventListener('click', () => {
                    handleAdvantageSelection(key, gameData);
                });
                advantagesGrid.appendChild(item);
            }
        };
        
        const handleAdvantageSelection = async (key, gameData) => {
            const gameRef = doc(db, "games", currentGameId);
            const judges = [...gameData.judges];
            const meIndex = judges.findIndex(j => j.uid === currentUser.uid);
            if (meIndex === -1) return;

            let myAdvantages = judges[meIndex].advantages || [];
            
            if (myAdvantages.includes(key)) {
                myAdvantages = myAdvantages.filter(adv => adv !== key);
            } else {
                if (myAdvantages.length < 2) {
                    myAdvantages.push(key);
                } else {
                    showMessage("Puoi scegliere solo 2 vantaggi!", 2000);
                    return;
                }
            }

            judges[meIndex].advantages = myAdvantages;
            await updateDoc(gameRef, { judges });
        };
        
        const renderPlayerAdvantages = (gameData, inModal = false) => {
            const container = inModal ? playerAdvantagesListModal : null; 
            const parentContainer = inModal ? playerAdvantagesContainerModal : null;
            if (!container || !parentContainer) return;
            
            if (gameData.gameMode === 'tournament') {
                parentContainer.style.display = 'none';
                return;
            }

            container.innerHTML = '';

            const me = gameData.judges.find(j => j.uid === currentUser.uid);
            if (!me || !me.advantages || me.advantages.length === 0) {
                parentContainer.style.display = 'none';
                return;
            }
            
            parentContainer.style.display = 'block';

            me.advantages.forEach(key => {
                const advInfo = advantages[key];
                const btn = document.createElement('button');
                btn.className = 'player-advantage-btn';
                btn.dataset.advantageKey = key;
                btn.innerHTML = `
                    ${advInfo.emoji}
                    <span class="tooltip">${advInfo.name}: ${advInfo.description}</span>
                `;
                
                const usedAdvantages = me.usedAdvantages || [];
                if (usedAdvantages.includes(key) || gameData.currentDuel?.usedAdvantages?.[me.uid]) {
                    btn.disabled = true;
                }

                btn.addEventListener('click', () => useAdvantage(key, gameData));
                container.appendChild(btn);
            });
        };

        const useAdvantage = async (key, gameData) => {
            if (!gameData.currentDuel || gameData.gameState !== 'voting') {
                showMessage("Puoi usare i vantaggi solo durante la fase di voto!", 3000);
                return;
            }
            
            if (key === 'bodyguard') {
                showBodyguardChoiceModal(gameData, key);
                return;
            }
            
            const gameRef = doc(db, "games", currentGameId);
            const judges = [...gameData.judges];
            const meIndex = judges.findIndex(j => j.uid === currentUser.uid);
            let usedAdvantages = judges[meIndex].usedAdvantages || [];

            if(usedAdvantages.includes(key) || gameData.currentDuel.usedAdvantages?.[currentUser.uid]) return;

            usedAdvantages.push(key);
            judges[meIndex].usedAdvantages = usedAdvantages;
            
            const advantagePath = `currentDuel.usedAdvantages.${currentUser.uid}`;
            await updateDoc(gameRef, { 
                judges,
                [advantagePath]: { key }
            });
            showMessage(`Vantaggio "${advantages[key].name}" attivato!`, 2000);
        };
        
        const showBodyguardChoiceModal = (gameData, advantageKey) => {
            const { attackerId, defenderId } = gameData.currentDuel;
            const allChars = [...gameData.characters, ...gameData.eliminated];
            const attacker = allChars.find(c => c.id === attackerId);
            const defender = allChars.find(c => c.id === defenderId);
            
            bodyguardChoiceActions.innerHTML = `
                <button class="btn-secondary" data-target-id="${attacker.id}">${attacker.name}</button>
                <button class="btn-secondary" data-target-id="${defender.id}">${defender.name}</button>
            `;
            bodyguardChoiceActions.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', async () => {
                    await useTargetedAdvantage(advantageKey, btn.dataset.targetId, gameData);
                    bodyguardChoiceModal.style.display = 'none';
                });
            });
            bodyguardChoiceModal.style.display = 'flex';
        };

        const showTargetedShotModal = (gameData) => {
            const { winnerId } = gameData.currentDuel;
            const allChars = gameData.characters.filter(c => c.territories.length > 0);
            const winner = allChars.find(c => c.id === winnerId);
            if (!winner) {
                targetedShotModal.style.display = 'none';
                if(currentUser.uid === gameData.hostId) startNextTournamentRound();
                return;
            };

            targetedShotWinnerText.textContent = `${winner.name} ha vinto!`;

            const neighbors = getValidNeighbors(winner, gameData);
            targetedShotActions.innerHTML = '';

            if (neighbors.length === 0) {
                targetedShotActions.innerHTML = `<p>Nessun avversario valido rimasto!</p>`;
                setTimeout(async () => {
                    targetedShotModal.style.display = 'none';
                    await updateDoc(doc(db, "games", currentGameId), { gameState: 'round_end_after_choice' });
                }, 3000);
            } else {
                neighbors.forEach(neighbor => {
                    const btn = document.createElement('button');
                    btn.className = 'btn-secondary';
                    btn.dataset.defenderId = neighbor.owner.id;
                    btn.textContent = `ATTACCA ${neighbor.owner.name}`;
                    btn.addEventListener('click', async () => {
                        btn.disabled = true;
                        await updateDoc(doc(db, "games", currentGameId), {
                            nextAttackerId: winnerId,
                            nextDefenderId: neighbor.owner.id,
                            gameState: 'round_end_after_choice'
                        });
                        targetedShotModal.style.display = 'none';
                    });
                    targetedShotActions.appendChild(btn);
                });
            }
            targetedShotModal.style.display = 'flex';
        };
        
        const useTargetedAdvantage = async (key, targetId, gameData) => {
             const gameRef = doc(db, "games", currentGameId);
             const judges = [...gameData.judges];
             const meIndex = judges.findIndex(j => j.uid === currentUser.uid);

            let usedAdvantages = judges[meIndex].usedAdvantages || [];
            if(usedAdvantages.includes(key) || gameData.currentDuel.usedAdvantages?.[currentUser.uid]) return;
            
             usedAdvantages.push(key);
             judges[meIndex].usedAdvantages = usedAdvantages;
             
             const advantagePath = `currentDuel.usedAdvantages.${currentUser.uid}`;
             await updateDoc(gameRef, { 
                 judges,
                 [advantagePath]: { key, target: targetId }
             });
             showMessage(`Vantaggio "${advantages[key].name}" attivato!`, 2000);
        };

        const showShieldChoiceModal = (gameData) => {
            const { attackerId, defenderId } = gameData.currentDuel;
            const allChars = [...gameData.characters, ...gameData.eliminated];
            const attacker = allChars.find(c => c.id === attackerId);
            const defender = allChars.find(c => c.id === defenderId);

            shieldChoiceActions.innerHTML = `
                <button class="btn-secondary" data-save-id="${attacker.id}">SALVA ${attacker.name}</button>
                <button class="btn-secondary" data-save-id="${defender.id}">SALVA ${defender.name}</button>
            `;
             shieldChoiceActions.querySelectorAll('button').forEach(btn => {
                 btn.addEventListener('click', async () => {
                      const savedCharName = btn.dataset.saveId === attacker.id ? attacker.name : defender.name;
                      await updateDoc(doc(db, "games", currentGameId), {
                          gameState: 'round_end',
                          message: `${savedCharName} è stato salvato dallo Scudo del Destino!`
                      });
                      shieldChoiceModal.style.display = 'none';
                 });
             });
             shieldChoiceModal.style.display = 'flex';
        }


        // --- EVENT LISTENERS ---
        showRosterConfigBtn.addEventListener('click', () => showScreen('roster-config-screen'));
        backToHomeBtn.addEventListener('click', () => showScreen('home-screen'));
        addCharBtn.addEventListener('click', handleAddCharacterFromCustom);
        createLobbyBtn.addEventListener('click', createGameFromRoster);
        joinGameBtn.addEventListener('click', joinGame);
        leaveLobbyBtn.addEventListener('click', leaveGame);
        startGameBtn.addEventListener('click', handleStartGame);
        leaveGameBtn.addEventListener('click', leaveGame);
        rematchBtn.addEventListener('click', handleRematch);
        newGameBtn.addEventListener('click', resetLocalState);
        gameCodeDisplay.addEventListener('click', () => {
             navigator.clipboard.writeText(gameCodeDisplay.textContent).then(() => {
                 showMessage('Codice copiato!', 1500);
             });
        });

        showCustomBtn.addEventListener('click', () => {
            customAddView.style.display = 'block';
            predefinedRosterView.style.display = 'none';
            showCustomBtn.classList.add('active');
            showPredefinedBtn.classList.remove('active');
        });

        showPredefinedBtn.addEventListener('click', () => {
            customAddView.style.display = 'none';
            predefinedRosterView.style.display = 'block';
            showCustomBtn.classList.remove('active');
            showPredefinedBtn.classList.add('active');
        });

         document.getElementById('game-mode-toggle').addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') return;
            selectedGameMode = e.target.dataset.mode;
            
            document.querySelectorAll('#game-mode-toggle button').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');

            if (selectedGameMode === 'classic') {
                modeDescription.textContent = 'Tutti contro tutti. Minimo 4 personaggi.';
            } else {
                modeDescription.textContent = '10 gironi da 20, poi finale. Servono esattamente 200 personaggi.';
            }
            updateRosterUI();
        });


        // Chat Event Listeners
        chatToggleBtn.addEventListener('click', () => chatContainer.classList.toggle('open'));
        chatSendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendChatMessage();
        });


        // --- Inizializzazione ---
        playerNameInput.value = localStorage.getItem('playerName') || '';
        updateRosterUI();
        renderPredefinedRoster();
        showCustomBtn.click();
    </script>
</body>
</html>

