<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imperialism Online: Roster Conquest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.4.0/dist/panzoom.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #00aaff;
            --text-color: #f0f0f0;
            --border-color: #444;
            --success-color: #4CAF50;
            --danger-color: #F44336;
            --warning-color: #ff9800;
            --font-main: 'Inter', sans-serif;
            --font-title: 'Russo One', sans-serif;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .screen {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }
        .screen.active { display: flex; }
        .container {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        h1, h2 {
            font-family: var(--font-title);
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input[type="number"], input[type="text"], input[type="url"] {
            width: 100%;
            padding: 12px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 1rem;
        }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            font-family: var(--font-title);
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            position: relative;
        }
        button:disabled { cursor: not-allowed; background-color: #555 !important; box-shadow: none !important; color: #999 !important; border-color: #555 !important; }
        .btn-primary { background-color: var(--primary-color); color: #fff; box-shadow: 0 0 15px var(--primary-color); }
        .btn-primary:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--primary-color); }
        .btn-secondary { background-color: var(--surface-color); color: var(--primary-color); border: 2px solid var(--primary-color); }
        .btn-secondary:not(:disabled):hover { background-color: var(--primary-color); color: #fff; }
        .btn-danger { background-color: var(--danger-color); color: #fff; box-shadow: 0 0 15px var(--danger-color); }
        .btn-danger:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--danger-color); }
        .game-code-display {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.5rem;
            font-family: var(--font-title);
            letter-spacing: 3px;
            border: 1px dashed var(--primary-color);
            cursor: pointer;
        }
        #player-list { list-style: none; padding: 0; }
        #player-list li { background: var(--bg-color); padding: 10px; border-radius: 5px; margin-bottom: 5px; }
        #player-list .host-tag { font-size: 0.8em; color: var(--primary-color); margin-left: 8px; }
        
        /* Roster Screen */
        #roster-list { max-height: 30vh; overflow-y: auto; margin-top: 15px; background-color: var(--bg-color); padding: 10px; border-radius: 8px;}
        .roster-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; border-bottom: 1px solid var(--border-color); }
        .roster-item:last-child { border-bottom: none; }
        .roster-item img { width: 40px; height: 40px; border-radius: 50%; margin-right: 15px; object-fit: cover;}
        .roster-item span { flex-grow: 1; }
        .roster-item button { padding: 5px 10px; font-size: 0.8rem; background-color: var(--danger-color); color: white; }

        /* Game Screen */
        #game-screen { width: 100vw; height: 100vh; padding: 0; }
        #arena-container { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            cursor: grab; 
            background-color: #111;
            background-image: radial-gradient(circle, #222 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #arena { display: grid; gap: 1px; transform-origin: center center; }
        .character-cell { 
            position: relative; 
            width: 100px; 
            height: 100px; 
            transition: all 0.5s ease;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        .character-cell img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .character-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.7); color: white; padding: 4px; font-size: 12px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        @keyframes roulette-highlight { 0%, 100% { box-shadow: 0 0 15px 5px #fff; } 50% { box-shadow: 0 0 25px 10px var(--primary-color); } }
        .roulette-active { animation: roulette-highlight 0.3s infinite; z-index: 10; transform: scale(1.05); }
        @keyframes target-highlight { 0%, 100% { box-shadow: 0 0 15px 5px var(--danger-color); transform: scale(1.05); } 50% { box-shadow: 0 0 25px 10px #ffdd00; transform: scale(1.1); } }
        .target-highlighted { animation: target-highlight 1s infinite; z-index: 10; }
        .attacker-selected { box-shadow: 0 0 20px 8px var(--success-color) !important; transform: scale(1.1); z-index: 10; }
        #game-ui-overlay { position: fixed; top: 20px; right: 20px; z-index: 100; }
        
        /* Temporary Leaderboard */
        #temp-leaderboard {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 250px;
            max-height: 60vh;
            background: rgba(44, 44, 44, 0.85);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 15px;
            z-index: 100;
            backdrop-filter: blur(3px);
            overflow-y: auto;
            color: var(--text-color);
            display: none;
        }
        #temp-leaderboard h3 {
            font-family: var(--font-title);
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        #temp-leaderboard-list {
            list-style: none;
            padding-left: 0;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-rank {
            font-family: var(--font-title);
            font-size: 1.2rem;
            margin-right: 15px;
            width: 30px;
            text-align: center;
        }
        .leaderboard-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }
        .leaderboard-name {
            flex-grow: 1;
            font-size: 0.9rem;
        }

        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 200; backdrop-filter: blur(5px); }
        .modal-content { background: var(--surface-color); padding: 40px; border-radius: 20px; text-align: center; width: 90%; max-width: 800px; box-shadow: 0 0 40px rgba(0, 170, 255, 0.5); border: 2px solid var(--primary-color); }
        .duel-container { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .combatant { display: flex; flex-direction: column; align-items: center; }
        .combatant img { width: 150px; height: 150px; object-fit: cover; border-radius: 50%; border: 5px solid var(--border-color); margin-bottom: 15px; }
        .combatant h3 { font-family: var(--font-title); font-size: 1.5rem; }
        .vs { font-family: var(--font-title); font-size: 4rem; color: var(--danger-color); text-shadow: 0 0 10px var(--danger-color); }
        .vote-actions { display: flex; justify-content: center; gap: 20px; margin-top: 30px; }
        .vote-btn { width: 180px; }
        #vote-timer { font-size: 2rem; margin-top: 15px; color: var(--warning-color); font-family: var(--font-title); }
        .reveal-section { display: none; margin-top: 20px; }
        .reveal-section h2 { font-size: 3rem; }
        .reveal-section p { font-size: 1.5rem; }
        .winner-reveal { color: var(--success-color); }
        .loser-reveal { color: var(--danger-color); }

        /* Results Screen */
        #results-screen .container { max-width: 800px; }
        #final-ranking-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        #final-ranking-table th, #final-ranking-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
        #final-ranking-table th { font-family: var(--font-title); color: var(--primary-color); }
        #final-ranking-table .rank-img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; margin-right: 10px; vertical-align: middle; }
        
        /* Message Overlay */
        #message-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 1000; display: flex; justify-content: center; align-items: flex-end; text-align: center; padding: 20px; padding-bottom: 50px; pointer-events: none; }
        #message-overlay h2 { font-size: 2.5rem; background: rgba(44, 44, 44, 0.85); padding: 15px 25px; border-radius: 15px; text-shadow: 0 0 10px var(--primary-color); animation: pulse 2s infinite; pointer-events: all; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Chat Styles */
        #chat-toggle-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 101;
            width: 80px;
            height: 50px;
        }
        #chat-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            height: 400px;
            background-color: var(--surface-color);
            border: 2px solid var(--primary-color);
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(110%);
            opacity: 0;
            pointer-events: none;
        }
        #chat-container.open {
            transform: translateY(0);
            opacity: 1;
            pointer-events: all;
        }
        #chat-header {
            padding: 10px;
            background-color: var(--bg-color);
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-family: var(--font-title);
        }
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .chat-message.sent {
            background-color: var(--primary-color);
            color: #fff;
            align-self: flex-end;
        }
        .chat-message.received {
            background-color: var(--bg-color);
            align-self: flex-start;
        }
        .chat-sender {
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--warning-color);
        }
        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border-color);
        }
        #chat-input { flex-grow: 1; margin-right: 10px; }
        #chat-send-btn { font-size: 0.9rem; padding: 10px; }

    </style>
</head>
<body>

    <!-- Schermata Iniziale -->
    <div id="home-screen" class="screen active">
        <div class="container">
            <h1>Imperialism Online</h1>
            <p style="text-align: center; margin-bottom: 20px;">Crea una partita e invita i tuoi amici a votare, o unisciti a una partita come giudice!</p>
            <div class="form-group">
                <label for="player-name">Il tuo nome (giudice):</label>
                <input type="text" id="player-name" placeholder="Super Giudice" maxlength="20">
            </div>
            <div class="button-group">
                <button id="show-roster-config-btn" class="btn-primary">Crea Partita</button>
            </div>
            <hr style="margin: 20px 0; border-color: var(--border-color);">
            <div class="form-group">
                <label for="join-code">Codice Partita:</label>
                <input type="text" id="join-code" placeholder="ABCDE" maxlength="5">
            </div>
            <div class="button-group">
                <button id="join-game-btn" class="btn-secondary">Unisciti come Giudice</button>
            </div>
        </div>
    </div>

    <!-- Schermata Configurazione Roster (solo Host) -->
    <div id="roster-config-screen" class="screen">
        <div class="container">
            <h1>Configura Roster</h1>
            <p>Aggiungi da 4 a 100 personaggi per la sfida.</p>
            <div class="form-group">
                <label for="char-name">Nome Personaggio:</label>
                <input type="text" id="char-name" placeholder="Es. Son Goku">
            </div>
            <div class="form-group">
                <label for="char-img">URL Immagine (PNG/JPG):</label>
                <input type="url" id="char-img" placeholder="https://.../goku.png">
            </div>
            <button id="add-char-btn" class="btn-secondary">Aggiungi Personaggio</button>
            <div id="roster-list"></div>
            <p id="char-counter" style="text-align: center; margin-top: 10px;">Personaggi: 0/100</p>
            <div class="button-group">
                <button id="create-lobby-btn" class="btn-primary" disabled>Crea Lobby (Min. 4)</button>
                 <button id="back-to-home-btn" class="btn-danger">Annulla</button>
            </div>
        </div>
    </div>

    <!-- Schermata Lobby -->
    <div id="lobby-screen" class="screen">
        <div class="container">
            <h1>Lobby di Gioco</h1>
            <p>Condividi questo codice con i tuoi amici (giudici):</p>
            <div id="game-code-display" class="game-code-display" title="Clicca per copiare">CARICAMENTO...</div>
            <h2 style="margin-top: 20px;">Giudici Connessi:</h2>
            <ul id="player-list"></ul>
            <div class="button-group">
                <button id="start-game-btn" class="btn-primary">Inizia Lotta!</button>
                <button id="leave-lobby-btn" class="btn-danger">Chiudi Lobby</button>
            </div>
        </div>
    </div>

    <!-- Schermata di Gioco -->
    <div id="game-screen" class="screen">
        <div id="game-ui-overlay">
            <button id="leave-game-btn" class="btn-danger">Abbandona</button>
        </div>
        <div id="temp-leaderboard">
            <h3>Classifica</h3>
            <ol id="temp-leaderboard-list"></ol>
        </div>
        <div id="arena-container">
            <div id="arena"></div>
        </div>
        
        <!-- Chat UI -->
        <div id="chat-container">
            <div id="chat-header">Chat di Gioco</div>
            <div id="chat-messages"></div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="Scrivi un messaggio...">
                <button id="chat-send-btn" class="btn-primary">Invia</button>
            </div>
        </div>
        <button id="chat-toggle-btn" class="btn-secondary">Chat</button>

    </div>
    
    <!-- Modale del Voto -->
    <div id="vote-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div id="vote-view">
                <h2>La Sfida!</h2>
                <div class="duel-container">
                    <div id="attacker-info" class="combatant"></div>
                    <div class="vs">VS</div>
                    <div id="defender-info" class="combatant"></div>
                </div>
                <h3>Chi vincerà? Vota!</h3>
                <div id="vote-actions" class="vote-actions"></div>
                <div id="vote-timer">30</div>
            </div>
            <div id="reveal-view" style="display: none;">
                <div id="winner-reveal" class="reveal-section winner-reveal">
                    <h2>SALVO!</h2>
                    <p id="winner-reveal-text"></p>
                </div>
                <div id="loser-reveal" class="reveal-section loser-reveal">
                    <h2>ELIMINATO!</h2>
                    <p id="loser-reveal-text"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Schermata dei Risultati -->
    <div id="results-screen" class="screen">
        <div class="container">
            <h1 id="winner-announcement"></h1>
            <h2>Classifica Finale</h2>
            <table id="final-ranking-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Personaggio</th>
                        <th>Uccisioni</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <div class="button-group">
                <button id="rematch-btn" class="btn-primary">Rivincita!</button>
                <button id="new-game-btn" class="btn-secondary">Nuova Partita</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay per Messaggi -->
    <div id="message-overlay" style="display: none;">
        <h2 id="message-text"></h2>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, deleteDoc, runTransaction, addDoc, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyAu6Yy9B_VFAek56ZI35lznAlLzRv0G4pY",
            authDomain: "imperialism-online.firebaseapp.com",
            projectId: "imperialism-online",
            storageBucket: "imperialism-online.firebasestorage.app",
            messagingSenderId: "1073749237649",
            appId: "1:1073749237649:web:b8c01c3db78a13fa454430",
            measurementId: "G-7GJK149KRR"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- RIFERIMENTI DOM ---
        const screens = document.querySelectorAll('.screen');
        const playerNameInput = document.getElementById('player-name');
        const showRosterConfigBtn = document.getElementById('show-roster-config-btn');
        const joinCodeInput = document.getElementById('join-code');
        const joinGameBtn = document.getElementById('join-game-btn');
        const backToHomeBtn = document.getElementById('back-to-home-btn');

        const charNameInput = document.getElementById('char-name');
        const charImgInput = document.getElementById('char-img');
        const addCharBtn = document.getElementById('add-char-btn');
        const rosterList = document.getElementById('roster-list');
        const charCounter = document.getElementById('char-counter');
        const createLobbyBtn = document.getElementById('create-lobby-btn');
        
        const gameCodeDisplay = document.getElementById('game-code-display');
        const playerList = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');

        const arenaContainer = document.getElementById('arena-container');
        const arena = document.getElementById('arena');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        const tempLeaderboard = document.getElementById('temp-leaderboard');
        const tempLeaderboardList = document.getElementById('temp-leaderboard-list');

        const voteModal = document.getElementById('vote-modal');
        const voteView = document.getElementById('vote-view');
        const revealView = document.getElementById('reveal-view');
        const attackerInfo = document.getElementById('attacker-info');
        const defenderInfo = document.getElementById('defender-info');
        const voteActions = document.getElementById('vote-actions');
        const voteTimer = document.getElementById('vote-timer');
        const winnerReveal = document.getElementById('winner-reveal');
        const loserReveal = document.getElementById('loser-reveal');
        const winnerRevealText = document.getElementById('winner-reveal-text');
        const loserRevealText = document.getElementById('loser-reveal-text');

        const winnerAnnouncement = document.getElementById('winner-announcement');
        const finalRankingTableBody = document.querySelector('#final-ranking-table tbody');
        const rematchBtn = document.getElementById('rematch-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');

        // Chat DOM References
        const chatContainer = document.getElementById('chat-container');
        const chatToggleBtn = document.getElementById('chat-toggle-btn');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');

        // --- STATO LOCALE ---
        let currentUser = null;
        let currentGameId = null;
        let unsubFromGame = null;
        let unsubFromChat = null;
        let panzoom;
        let localTimers = [];
        let localRoster = [];
        let animationInterval = null;
        let duelResolutionTimer = null;

        // --- FUNZIONI DI NAVIGAZIONE E UI ---
        const showScreen = (screenId) => {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            
            const isGameScreen = screenId === 'game-screen';
            chatToggleBtn.style.display = isGameScreen ? 'block' : 'none';
            tempLeaderboard.style.display = isGameScreen ? 'block' : 'none';
            if (!isGameScreen) {
                chatContainer.classList.remove('open');
            }
        };

        const showMessage = (text, duration = 3000) => {
            messageText.textContent = text;
            messageOverlay.style.display = 'flex';
            if (duration > 0) {
                setTimeout(() => messageOverlay.style.display = 'none', duration);
            }
        };

        const clearLocalTimers = () => {
            localTimers.forEach(timer => clearInterval(timer));
            localTimers = [];
        };
        
        // --- AUTENTICAZIONE E INIZIALIZZAZIONE ---
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUser = user;
            } else {
                signInAnonymously(auth).catch(error => console.error("Anonymous sign-in error:", error));
            }
        });
        
        // --- CONFIGURAZIONE ROSTER (HOST) ---
        const handleAddCharacter = () => {
            const name = charNameInput.value.trim();
            const imgSrc = charImgInput.value.trim();

            if (!name || !imgSrc) {
                showMessage("Inserisci nome e URL dell'immagine.", 2000);
                return;
            }
            if (localRoster.length >= 100) {
                showMessage("Hai raggiunto il limite di 100 personaggi.", 2000);
                return;
            }

            try {
                new URL(imgSrc); 
            } catch (_) {
                showMessage("L'URL dell'immagine non è valido.", 2000);
                return;
            }

            const charId = Date.now().toString() + Math.random(); 
            localRoster.push({ id: charId, name, imgSrc });
            
            charNameInput.value = '';
            charImgInput.value = '';
            charNameInput.focus();
            
            updateRosterUI();
        };

        const handleRemoveCharacter = (charId) => {
            localRoster = localRoster.filter(c => c.id !== charId);
            updateRosterUI();
        };

        const updateRosterUI = () => {
            rosterList.innerHTML = '';
            localRoster.forEach(char => {
                const item = document.createElement('div');
                item.className = 'roster-item';
                item.innerHTML = `
                    <img src="${char.imgSrc}" alt="${char.name}" onerror="this.style.display='none'">
                    <span>${char.name}</span>
                    <button data-char-id="${char.id}">Rimuovi</button>
                `;
                item.querySelector('button').addEventListener('click', () => handleRemoveCharacter(char.id));
                rosterList.appendChild(item);
            });
            
            const count = localRoster.length;
            charCounter.textContent = `Personaggi: ${count}/100`;
            createLobbyBtn.disabled = count < 4;
        };
        
        // --- LOGICA DELLA LOBBY ---
        const createGameFromRoster = async () => {
            const judgeName = playerNameInput.value.trim();
            if (!judgeName || !currentUser) {
                showMessage("Inserisci il tuo nome da giudice per continuare.", 2000);
                showScreen('home-screen');
                return;
            }
            if (localRoster.length < 4) return;

            createLobbyBtn.disabled = true;
            const gameId = generateGameId();
            const gameRef = doc(db, "games", gameId);

            const initialGameState = {
                gameId: gameId,
                hostId: currentUser.uid,
                judges: [{ uid: currentUser.uid, name: judgeName }],
                characters: localRoster, 
                eliminated: [],
                gameState: "lobby",
                message: `Benvenuto nella lobby! In attesa che l'host inizi la partita.`
            };

            try {
                await setDoc(gameRef, initialGameState);
                joinLobby(gameId, judgeName);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Impossibile creare la partita. Riprova.", 3000);
                createLobbyBtn.disabled = false;
            }
        };

        const joinGame = async () => {
            const judgeName = playerNameInput.value.trim();
            const gameId = joinCodeInput.value.trim().toUpperCase();
            if (!judgeName || !gameId || !currentUser) {
                showMessage("Inserisci il tuo nome e il codice partita.", 2000);
                return;
            }

            joinGameBtn.disabled = true;
            const gameRef = doc(db, "games", gameId);
            
            try {
                 await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Partita non trovata!";

                    const gameData = gameDoc.data();
                    if (gameData.gameState !== 'lobby') throw "La partita è già iniziata!";

                    const judges = gameData.judges;
                    if (!judges.some(p => p.uid === currentUser.uid)) {
                        judges.push({ uid: currentUser.uid, name: judgeName });
                    }
                    transaction.update(gameRef, { judges });
                });
                joinLobby(gameId, judgeName);
            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Impossibile unirsi: " + error, 3000);
                joinGameBtn.disabled = false;
            }
        };

        const joinLobby = (gameId, judgeName) => {
            currentGameId = gameId;
            localStorage.setItem('playerName', judgeName);
            showScreen('lobby-screen');
            listenToGameUpdates(gameId);
            listenToChatUpdates(gameId); 
        };

        const leaveGame = async () => {
             if (!currentGameId || !currentUser) return;
             
             const gameRef = doc(db, "games", currentGameId);
             try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) {
                    resetLocalState();
                    return;
                }
                let gameData = gameDoc.data();

                if (gameData.hostId === currentUser.uid) {
                    await deleteDoc(gameRef);
                } else {
                    let judges = gameData.judges.filter(p => p.uid !== currentUser.uid);
                    await updateDoc(gameRef, { judges });
                }
             } catch (error) {
                 console.error("Error leaving game: ", error);
             } finally {
                 resetLocalState();
             }
        };

        const listenToGameUpdates = (gameId) => {
            const gameRef = doc(db, "games", gameId);
            if (unsubFromGame) unsubFromGame();

            unsubFromGame = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("La partita è stata chiusa dall'host.", 4000);
                    resetLocalState();
                    return;
                }
                const gameData = doc.data();
                const isHost = currentUser && currentUser.uid === gameData.hostId;

                
                if (isHost && gameData.gameState === 'voting') {
                    const votesCount = Object.keys(gameData.currentDuel.votes || {}).length;
                    const judgesCount = gameData.judges.length;
                    if (votesCount >= judgesCount) {
                        clearTimeout(duelResolutionTimer);
                        resolveDuel();
                        return; 
                    }
                }
                
                updateUI(gameData);
            });
        };

        const updateUI = (gameData) => {
            const isHost = currentUser && currentUser.uid === gameData.hostId;

            if (gameData.gameState === 'lobby') {
                showScreen('lobby-screen');
                gameCodeDisplay.textContent = gameData.gameId;
                playerList.innerHTML = '';
                gameData.judges.forEach(judge => {
                    const li = document.createElement('li');
                    li.textContent = judge.name;
                    if (judge.uid === gameData.hostId) {
                        const hostTag = document.createElement('span');
                        hostTag.className = 'host-tag';
                        hostTag.textContent = '(Host)';
                        li.appendChild(hostTag);
                    }
                    playerList.appendChild(li);
                });
                startGameBtn.style.display = isHost ? 'block' : 'none';
                leaveLobbyBtn.textContent = isHost ? 'Chiudi Lobby' : 'Esci dalla Lobby';
            }
            
            // This needs to be called in all in-game states
            if (['selection_phase', 'voting', 'reveal_winner', 'reveal_loser', 'round_end'].includes(gameData.gameState)) {
                updateTemporaryLeaderboard(gameData);
            }
            
            switch(gameData.gameState) {
                case 'starting':
                    showScreen('game-screen');
                    showMessage("La lotta sta per iniziare...", 0);
                    createArena(gameData);
                    break;
                case 'selection_phase':
                    showScreen('game-screen');
                    showMessage(gameData.message, 0);
                    updateArena(gameData);
                    displaySelectionAnimation(gameData);
                    break;
                case 'voting':
                    showScreen('game-screen');
                    updateArena(gameData);
                    showMessage(`È ora di votare!`, 0);
                    showVoteModal(gameData);
                    break;
                case 'reveal_winner':
                case 'reveal_loser':
                case 'round_end':
                     showScreen('game-screen');
                     showMessage(gameData.message, 4000);
                     updateArena(gameData);
                     handleRevealSequence(gameData);
                     clearLocalTimers();
                     break;
                case 'finished':
                    showScreen('results-screen');
                    if (unsubFromGame) unsubFromGame();
                    unsubFromGame = null;
                    displayResults(gameData);
                    rematchBtn.style.display = isHost ? 'block' : 'none';
                    break;
            }
        };

        const handleStartGame = async () => {
            if (!currentGameId || !currentUser) return;
            const gameRef = doc(db, "games", currentGameId);
            const gameDoc = await getDoc(gameRef);
            if (!gameDoc.exists()) return;
            
            const gameData = gameDoc.data();
            const shuffledCharacters = shuffleArray([...gameData.characters]);
            shuffledCharacters.forEach((char, index) => {
                char.territories = [index];
            });

            const gridSize = shuffledCharacters.length;
            const ratio = window.innerWidth / window.innerHeight;
            const cols = Math.ceil(Math.sqrt(gridSize * ratio));
            const rows = Math.ceil(gridSize / cols);
            
            await updateDoc(gameRef, {
                gameState: 'starting',
                characters: shuffledCharacters,
                gridSize, cols, rows,
                message: 'La partita sta per iniziare...'
            });
            
            setTimeout(() => {
                if (currentUser.uid === gameData.hostId) {
                    executeRoundTurn();
                }
            }, 3000);
        };
        
        // --- LOGICA DI GIOCO ---
        let isLogicRunning = false;
        const executeRoundTurn = async () => {
            if (isLogicRunning || !currentGameId) return;
            isLogicRunning = true;
            try {
                const gameRef = doc(db, "games", currentGameId);
                let gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) { isLogicRunning = false; return; }
                let gameData = gameDoc.data();

                
                let activeCharacters = gameData.characters.filter(c => c.territories.length > 0);
                let attacker, neighbors;
                let validAttackerFound = false;
                let shuffledAttackers = shuffleArray([...activeCharacters]);

                for (const potentialAttacker of shuffledAttackers) {
                    const potentialNeighbors = getValidNeighbors(potentialAttacker, gameData);
                    if (potentialNeighbors.length > 0) {
                        attacker = potentialAttacker;
                        neighbors = potentialNeighbors;
                        validAttackerFound = true;
                        break;
                    }
                }

                if (!validAttackerFound) {
                    await updateDoc(gameRef, { message: "Nessuna mossa valida! Si salta il turno.", gameState: 'round_end' });
                    setTimeout(() => { if (currentUser.uid === gameData.hostId) executeRoundTurn(); }, 4000);
                    isLogicRunning = false;
                    return;
                }

                const defender = neighbors[Math.floor(Math.random() * neighbors.length)].owner;
                
                await updateDoc(gameRef, {
                    gameState: 'selection_phase',
                    currentDuel: {
                        attackerId: attacker.id,
                        defenderId: defender.id,
                    },
                    message: `${attacker.name} si prepara ad attaccare!`
                });

                
                setTimeout(() => {
                    if (!currentGameId) return; 
                    updateDoc(gameRef, {
                        'currentDuel.votes': {},
                        'currentDuel.voteDeadline': Date.now() + 30000,
                        gameState: 'voting',
                        message: `${attacker.name} attacca ${defender.name}!`
                    });
                    startVoteTimerOnHost(gameData.hostId);
                }, 6000); 

            } catch (error) {
                console.error("Error in turn execution:", error);
            } finally {
                isLogicRunning = false;
            }
        };


        const displaySelectionAnimation = (gameData) => {
            clearInterval(animationInterval);
            document.querySelectorAll('.roulette-active, .target-highlighted, .attacker-selected').forEach(el => el.classList.remove('roulette-active', 'target-highlighted', 'attacker-selected'));
            
            if (gameData.gameState !== 'selection_phase' || !gameData.currentDuel) return;

            const { attackerId } = gameData.currentDuel;
            if (!attackerId) return;

            const activeCharacters = gameData.characters.filter(c => c.territories.length > 0);

            
            let lastHighlight = null;
            let rouletteCount = 0;
            animationInterval = setInterval(() => {
                if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                const randomChar = activeCharacters[Math.floor(Math.random() * activeCharacters.length)];
                const cell = arena.querySelector(`[data-owner-id='${randomChar.id}']`);
                if (cell) { 
                    cell.classList.add('roulette-active');
                    lastHighlight = cell;
                }
                rouletteCount++;
                if(rouletteCount > 18) { // ~2.7 seconds
                    clearInterval(animationInterval);
                    if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                    
                    
                    const attackerCell = arena.querySelector(`[data-owner-id='${attackerId}']`);
                    if (attackerCell) attackerCell.classList.add('attacker-selected');

                    
                    const attacker = activeCharacters.find(c => c.id === attackerId);
                    if (!attacker) return;
                    const neighbors = getValidNeighbors(attacker, gameData);
                    if (neighbors.length > 0) {
                        let lastTargetHighlight = null;
                        let targetCount = 0;
                        animationInterval = setInterval(() => {
                            if (lastTargetHighlight) lastTargetHighlight.classList.remove('target-highlighted');
                            if (neighbors.length === 1) {
                                const targetCell = arena.querySelector(`[data-index='${neighbors[0].cellIndex}']`);
                                if (targetCell) targetCell.classList.add('target-highlighted');
                            } else {
                                const randomTarget = neighbors[Math.floor(Math.random() * neighbors.length)];
                                const targetCell = arena.querySelector(`[data-index='${randomTarget.cellIndex}']`);
                                if (targetCell) { 
                                    targetCell.classList.add('target-highlighted');
                                    lastTargetHighlight = targetCell;
                                }
                            }
                            targetCount++;
                            if(targetCount > 18) { // ~2.7 seconds
                                clearInterval(animationInterval);
                                if(lastTargetHighlight) lastTargetHighlight.classList.remove('target-highlighted');
                            }
                        }, 150);
                    }
                }
            }, 150);
        };

        const startVoteTimerOnHost = (hostId) => {
            if (currentUser.uid !== hostId) return;
            clearTimeout(duelResolutionTimer);
            duelResolutionTimer = setTimeout(resolveDuel, 31000);
        };
        
        const castVote = async (winnerId) => {
            if (!currentGameId || !currentUser) return;
            document.querySelectorAll('.vote-btn').forEach(b => b.disabled = true);
            
            const gameRef = doc(db, "games", currentGameId);
            const votePath = `currentDuel.votes.${currentUser.uid}`;
            await updateDoc(gameRef, { [votePath]: winnerId });
        };
        
        const resolveDuel = async () => {
            if (!currentGameId) return;
            const gameRef = doc(db, "games", currentGameId);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Game not found.";
                    let gameData = gameDoc.data();

                    if(gameData.gameState !== 'voting') return;
                    
                    const { attackerId, defenderId, votes } = gameData.currentDuel;
                    const voteCounts = { [attackerId]: 0, [defenderId]: 0 };
                    Object.values(votes || {}).forEach(vote => voteCounts[vote]++);

                    let winnerId, loserId;
                    if (voteCounts[attackerId] > voteCounts[defenderId]) { [winnerId, loserId] = [attackerId, defenderId]; }
                    else if (voteCounts[defenderId] > voteCounts[attackerId]) { [winnerId, loserId] = [defenderId, attackerId]; }
                    else {
                        winnerId = Math.random() < 0.5 ? attackerId : defenderId;
                        loserId = winnerId === attackerId ? defenderId : attackerId;
                    }
                    
                    let characters = [...gameData.characters];
                    const winnerIndex = characters.findIndex(c => c.id === winnerId);
                    const loserIndex = characters.findIndex(c => c.id === loserId);

                    characters[winnerIndex].eliminations = (characters[winnerIndex].eliminations || 0) + 1;
                    characters[winnerIndex].territories.push(...characters[loserIndex].territories);
                    characters[loserIndex].territories = [];

                    let eliminated = gameData.eliminated;
                    eliminated.push({ ...characters[loserIndex], eliminatedBy: characters[winnerIndex].name });
                    
                    const activeCharacters = characters.filter(c => c.territories.length > 0);
                    
                    const message = `${characters[winnerIndex].name} ha sconfitto ${characters[loserIndex].name}!`;

                    const finalUpdate = {
                        characters: characters,
                        eliminated,
                        message,
                        'currentDuel.winnerId': winnerId,
                        'currentDuel.loserId': loserId,
                        'currentDuel.voteCounts': voteCounts,
                    };

                    if (activeCharacters.length <= 1) {
                        finalUpdate.gameState = 'finished';
                        finalUpdate.message = `La partita è finita! Il vincitore è ${activeCharacters[0].name}!`;
                    } else {
                        finalUpdate.gameState = 'reveal_winner';
                    }
                    transaction.update(gameRef, finalUpdate);
                });
            } catch(error) {
                console.error("Error resolving duel:", error);
            }
        };
        
        const handleRevealSequence = async (gameData) => {
            const isHost = currentUser.uid === gameData.hostId;
            const { winnerId, loserId, voteCounts } = gameData.currentDuel;
            if (!winnerId || !loserId) return;

            const allChars = [...gameData.characters, ...gameData.eliminated];
            const winner = allChars.find(c => c.id === winnerId);
            const loser = allChars.find(c => c.id === loserId);
            if(!winner || !loser) return;
            
            if (gameData.gameState === 'reveal_winner') {
                voteModal.style.display = 'flex';
                voteView.style.display = 'none';
                revealView.style.display = 'block';
                winnerRevealText.textContent = `${winner.name} con ${voteCounts[winnerId]} voti`;
                winnerReveal.style.display = 'block';
                loserReveal.style.display = 'none';

                if (isHost) {
                    setTimeout(() => {
                        updateDoc(doc(db, "games", currentGameId), { gameState: 'reveal_loser' });
                    }, 2500);
                }
            } else if (gameData.gameState === 'reveal_loser') {
                voteModal.style.display = 'flex';
                loserRevealText.textContent = `${loser.name} con ${voteCounts[loserId]} voti`;
                loserReveal.style.display = 'block';

                if (isHost) {
                    setTimeout(() => {
                        updateDoc(doc(db, "games", currentGameId), { gameState: 'round_end' });
                    }, 2500);
                }
            } else if (gameData.gameState === 'round_end') {
                voteModal.style.display = 'none';
                 if (isHost) {
                    setTimeout(() => {
                        executeRoundTurn();
                    }, 2000);
                }
            }
        };

        // --- FUNZIONI DI VISUALIZZAZIONE GIOCO ---
        const createArena = (gameData) => {
            arena.innerHTML = '';
            arena.style.gridTemplateColumns = `repeat(${gameData.cols}, 100px)`;
            const grid = new Array(gameData.cols * gameData.rows).fill(null);
            
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);
            activeChars.forEach(char => {
                char.territories.forEach(index => { grid[index] = char; });
            });

            for(let i = 0; i < grid.length; i++) {
                const character = grid[i];
                const cell = document.createElement('div');
                cell.className = 'character-cell';
                cell.dataset.index = i;
                if (character) {
                    cell.dataset.ownerId = character.id;
                    cell.style.border = `3px solid ${character.color || getRandomColor()}`;
                    cell.innerHTML = `
                        <img src="${character.imgSrc}" alt="${character.name}" onerror="this.src='https://placehold.co/100x100/1a1a1a/444?text=X'">
                        <div class="character-name">${character.name}</div>
                    `;
                } else {
                    cell.style.visibility = 'hidden';
                }
                arena.appendChild(cell);
            }
            setupPanzoom();
        };

        const updateArena = (gameData) => {
            document.querySelectorAll('.attacker-selected, .target-highlighted').forEach(el => el.classList.remove('attacker-selected', 'target-highlighted'));
            
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);

            arena.querySelectorAll('.character-cell').forEach(cell => {
                const owner = activeChars.find(c => c.territories.includes(parseInt(cell.dataset.index)));
                if (owner) {
                    if (cell.dataset.ownerId !== owner.id) {
                        cell.dataset.ownerId = owner.id;
                        cell.style.borderColor = owner.color || getRandomColor();
                        cell.querySelector('img').src = owner.imgSrc;
                        cell.querySelector('.character-name').textContent = owner.name;
                    }
                    cell.style.opacity = 1;
                } else {
                    cell.style.opacity = 0.3;
                }
            });

            if (gameData.currentDuel?.attackerId) {
                const attackerCell = arena.querySelector(`[data-owner-id='${gameData.currentDuel.attackerId}']`);
                if(attackerCell) attackerCell.classList.add('attacker-selected');
            }
        };

        const updateTemporaryLeaderboard = (gameData) => {
            if (!gameData.characters) return;

            const totalCharacters = gameData.characters.length;
            const eliminatedList = gameData.eliminated || [];

            tempLeaderboardList.innerHTML = ''; 

            eliminatedList.forEach((char, index) => {
                const rank = totalCharacters - index;
                const li = document.createElement('li');
                li.className = 'leaderboard-item';
                li.innerHTML = `
                    <span class="leaderboard-rank">${rank}</span>
                    <img src="${char.imgSrc}" class="leaderboard-img" alt="${char.name}">
                    <span class="leaderboard-name">${char.name}</span>
                `;
                tempLeaderboardList.appendChild(li);
            });
        };

        const showVoteModal = (gameData) => {
             const { attackerId, defenderId, votes, voteDeadline } = gameData.currentDuel;
             if (!attackerId || !defenderId) {
                console.error("Duel data incomplete:", gameData.currentDuel);
                showMessage("Errore: Sfidanti non validi.", 3000);
                return;
             }
             
             const allChars = [...gameData.characters, ...gameData.eliminated];
             const attacker = allChars.find(c => c.id === attackerId);
             const defender = allChars.find(c => c.id === defenderId);

             if (!attacker || !defender) {
                console.error("Could not find attacker or defender from IDs.", { attackerId, defenderId });
                showMessage("Errore: Dati sfidanti non trovati.", 3000);
                return;
             }
            
             attackerInfo.innerHTML = `<img src="${attacker.imgSrc}"><h3>${attacker.name}</h3>`;
             defenderInfo.innerHTML = `<img src="${defender.imgSrc}"><h3>${defender.name}</h3>`;
             voteActions.innerHTML = `
                <button class="btn-primary vote-btn" data-winner-id="${attackerId}">VOTA ${attacker.name}</button>
                <button class="btn-primary vote-btn" data-winner-id="${defenderId}">VOTA ${defender.name}</button>
             `;
             
             const hasVoted = votes && votes[currentUser.uid];
             document.querySelectorAll('.vote-btn').forEach(btn => {
                if(hasVoted) btn.disabled = true;
                btn.addEventListener('click', () => castVote(btn.dataset.winnerId));
             });

             voteModal.style.display = 'flex';
             voteView.style.display = 'block';
             revealView.style.display = 'none';
             
             clearLocalTimers();
             const timerInterval = setInterval(() => {
                 const timeLeft = Math.max(0, Math.ceil((voteDeadline - Date.now()) / 1000));
                 voteTimer.textContent = timeLeft;
                 if (timeLeft <= 0) clearInterval(timerInterval);
             }, 1000);
             localTimers.push(timerInterval);
        };
        
        const displayResults = (gameData) => {
            const winner = gameData.characters.find(c => c.territories.length > 0);
            winnerAnnouncement.textContent = `IL VINCITORE È ${winner.name}!`;

            const finalRankings = [winner, ...[...gameData.eliminated].reverse()];
            
            finalRankingTableBody.innerHTML = '';
            finalRankings.forEach((char, i) => {
                finalRankingTableBody.innerHTML += `
                    <tr>
                        <td>${i + 1}</td>
                        <td><img src="${char.imgSrc}" class="rank-img">${char.name}</td>
                        <td>${char.eliminations || 0}</td>
                    </tr>`;
            });
        };

        const handleRematch = async () => {
             if (!currentGameId || !currentUser) return;
             const gameRef = doc(db, "games", currentGameId);
             
             try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) return;
                const gameData = gameDoc.data();
                
                await updateDoc(gameRef, {
                    gameState: 'lobby',
                    characters: localRoster, 
                    eliminated: [],
                    currentDuel: null,
                    judges: gameData.judges
                });
                listenToGameUpdates(currentGameId);
             } catch (error) {
                 console.error("Error on rematch:", error);
             }
        };

        // --- CHAT FUNCTIONS ---
        const listenToChatUpdates = (gameId) => {
            if (unsubFromChat) unsubFromChat();
            const chatRef = collection(db, "games", gameId, "chat");
            const q = query(chatRef, orderBy("timestamp"));

            unsubFromChat = onSnapshot(q, (snapshot) => {
                chatMessages.innerHTML = '';
                snapshot.forEach(doc => {
                    const msg = doc.data();
                    const msgDiv = document.createElement('div');
                    msgDiv.classList.add('chat-message');
                    msgDiv.classList.add(msg.uid === currentUser.uid ? 'sent' : 'received');
                    
                    let senderHTML = '';
                    if (msg.uid !== currentUser.uid) {
                        senderHTML = `<div class="chat-sender">${msg.senderName}</div>`;
                    }
                    
                    msgDiv.innerHTML = `${senderHTML}<div>${msg.text}</div>`;
                    chatMessages.appendChild(msgDiv);
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        };

        const sendChatMessage = async () => {
            const text = chatInput.value.trim();
            if (text === '' || !currentGameId || !currentUser) return;

            const name = localStorage.getItem('playerName') || 'Giudice';
            const chatRef = collection(db, "games", currentGameId, "chat");
            
            try {
                await addDoc(chatRef, {
                    uid: currentUser.uid,
                    senderName: name,
                    text: text,
                    timestamp: serverTimestamp()
                });
                chatInput.value = '';
            } catch (error) {
                console.error("Error sending message:", error);
                showMessage("Impossibile inviare il messaggio.", 2000);
            }
        };


        // --- FUNZIONI DI UTILITÀ ---
        const resetLocalState = () => {
             if (unsubFromGame) unsubFromGame();
             if (unsubFromChat) unsubFromChat();
             unsubFromGame = null;
             unsubFromChat = null;
             currentGameId = null;
             isLogicRunning = false;
             localRoster = [];
             clearLocalTimers();
             showScreen('home-screen');
        };

        const generateGameId = () => Math.random().toString(36).substring(2, 7).toUpperCase();
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        const getRandomColor = () => `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;

        const getValidNeighbors = (character, gameData) => {
            const neighbors = [];
            const { cols } = gameData;
            const activeChars = gameData.characters.filter(c => c.territories.length > 0);

            character.territories.forEach(index => {
                const x = index % cols;
                const y = Math.floor(index / cols);
                [{ dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }].forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    const neighborIndex = newY * cols + newX;
                    const owner = activeChars.find(c => c.territories.includes(neighborIndex));
                    if (owner && owner.id !== character.id && !neighbors.some(n => n.owner.id === owner.id)) {
                        neighbors.push({ owner, cellIndex: neighborIndex });
                    }
                });
            });
            return neighbors;
        };
        
        const setupPanzoom = () => {
             if (panzoom) panzoom.destroy();
             panzoom = Panzoom(arena, { maxScale: 5, minScale: 0.2, canvas: true });
             arenaContainer.addEventListener('wheel', panzoom.zoomWithWheel);
             setTimeout(() => {
                const containerRect = arenaContainer.getBoundingClientRect();
                const elemRect = arena.getBoundingClientRect();
                if (elemRect.width === 0) return;
                const scale = Math.min(containerRect.width / elemRect.width, containerRect.height / elemRect.height) * 0.95;
                panzoom.zoom(scale, { animate: true });
             }, 250);
        };


        // --- EVENT LISTENERS ---
        showRosterConfigBtn.addEventListener('click', () => showScreen('roster-config-screen'));
        backToHomeBtn.addEventListener('click', () => showScreen('home-screen'));
        addCharBtn.addEventListener('click', handleAddCharacter);
        createLobbyBtn.addEventListener('click', createGameFromRoster);
        joinGameBtn.addEventListener('click', joinGame);
        leaveLobbyBtn.addEventListener('click', leaveGame);
        startGameBtn.addEventListener('click', handleStartGame);
        leaveGameBtn.addEventListener('click', leaveGame);
        rematchBtn.addEventListener('click', handleRematch);
        newGameBtn.addEventListener('click', resetLocalState);
        gameCodeDisplay.addEventListener('click', () => {
             navigator.clipboard.writeText(gameCodeDisplay.textContent).then(() => {
                showMessage('Codice copiato!', 1500);
             });
        });

        // Chat Event Listeners
        chatToggleBtn.addEventListener('click', () => chatContainer.classList.toggle('open'));
        chatSendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendChatMessage();
        });


        // --- Inizializzazione ---
        playerNameInput.value = localStorage.getItem('playerName') || '';
        updateRosterUI();
    </script>
</body>
</html>

