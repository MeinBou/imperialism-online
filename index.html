<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imperialism Online: Roster Conquest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.4.0/dist/panzoom.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #00aaff;
            --text-color: #f0f0f0;
            --border-color: #444;
            --success-color: #4CAF50;
            --danger-color: #F44336;
            --warning-color: #ff9800;
            --font-main: 'Inter', sans-serif;
            --font-title: 'Russo One', sans-serif;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .screen {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }
        .screen.active { display: flex; }
        .container {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        h1, h2 {
            font-family: var(--font-title);
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 12px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 1rem;
        }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            font-family: var(--font-title);
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            position: relative;
        }
        button:disabled { cursor: not-allowed; background-color: #555 !important; box-shadow: none !important; color: #999 !important; border-color: #555 !important; }
        .btn-primary { background-color: var(--primary-color); color: #fff; box-shadow: 0 0 15px var(--primary-color); }
        .btn-primary:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--primary-color); }
        .btn-secondary { background-color: var(--surface-color); color: var(--primary-color); border: 2px solid var(--primary-color); }
        .btn-secondary:not(:disabled):hover { background-color: var(--primary-color); color: #fff; }
        .btn-danger { background-color: var(--danger-color); color: #fff; box-shadow: 0 0 15px var(--danger-color); }
        .btn-danger:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 0 25px var(--danger-color); }
        .game-code-display {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.5rem;
            font-family: var(--font-title);
            letter-spacing: 3px;
            border: 1px dashed var(--primary-color);
            cursor: pointer;
        }
        #player-list { list-style: none; padding: 0; }
        #player-list li { background: var(--bg-color); padding: 10px; border-radius: 5px; margin-bottom: 5px; }
        #player-list .host-tag { font-size: 0.8em; color: var(--primary-color); margin-left: 8px; }
        
        /* Game Screen */
        #game-screen { width: 100vw; height: 100vh; padding: 0; }
        #arena-container { width: 100%; height: 100%; overflow: hidden; cursor: grab; }
        #arena { display: grid; gap: 1px; transform-origin: center center; }
        .character-cell { position: relative; width: 100px; height: 100px; transition: all 0.5s ease; }
        .character-cell img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .character-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.7); color: white; padding: 4px; font-size: 12px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        @keyframes roulette-highlight { 0%, 100% { box-shadow: 0 0 15px 5px #fff; } 50% { box-shadow: 0 0 25px 10px var(--primary-color); } }
        .roulette-active { animation: roulette-highlight 0.3s infinite; z-index: 10; transform: scale(1.05); }
        @keyframes target-highlight { 0%, 100% { box-shadow: 0 0 15px 5px var(--danger-color); transform: scale(1.05); } 50% { box-shadow: 0 0 25px 10px #ffdd00; transform: scale(1.1); } }
        .target-highlighted { animation: target-highlight 1s infinite; z-index: 10; }
        .attacker-selected { box-shadow: 0 0 20px 8px var(--success-color) !important; transform: scale(1.1); z-index: 10; }
        #game-ui-overlay { position: fixed; top: 20px; right: 20px; z-index: 100; }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 200; backdrop-filter: blur(5px); }
        .modal-content { background: var(--surface-color); padding: 40px; border-radius: 20px; text-align: center; width: 90%; max-width: 800px; box-shadow: 0 0 40px rgba(0, 170, 255, 0.5); border: 2px solid var(--primary-color); }
        .duel-container { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .combatant { display: flex; flex-direction: column; align-items: center; }
        .combatant img { width: 150px; height: 150px; object-fit: cover; border-radius: 50%; border: 5px solid var(--border-color); margin-bottom: 15px; }
        .combatant h3 { font-family: var(--font-title); font-size: 1.5rem; }
        .vs { font-family: var(--font-title); font-size: 4rem; color: var(--danger-color); text-shadow: 0 0 10px var(--danger-color); }
        .vote-actions { display: flex; justify-content: center; gap: 20px; margin-top: 30px; }
        .vote-btn { width: 180px; }
        .vote-btn .vote-count { background: rgba(0,0,0,0.5); border-radius: 50%; padding: 5px 10px; position: absolute; top: -10px; right: -10px; font-size: 1rem; }
        #vote-timer { font-size: 2rem; margin-top: 15px; color: var(--warning-color); font-family: var(--font-title); }
        
        /* Results Screen */
        #results-screen .container { max-width: 800px; }
        .ranking-tables { display: flex; justify-content: space-around; gap: 30px; margin-top: 20px; flex-wrap: wrap; }
        .ranking-table { flex: 1; min-width: 300px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
        th { font-family: var(--font-title); color: var(--primary-color); }
        .rank-img { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; margin-right: 10px; vertical-align: middle; }
        
        /* Message Overlay */
        #message-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 1000; display: flex; justify-content: center; align-items: flex-end; text-align: center; padding: 20px; padding-bottom: 50px; pointer-events: none; }
        #message-overlay h2 { font-size: 2.5rem; background: rgba(44, 44, 44, 0.85); padding: 15px 25px; border-radius: 15px; text-shadow: 0 0 10px var(--primary-color); animation: pulse 2s infinite; pointer-events: all; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <!-- Schermata Iniziale -->
    <div id="home-screen" class="screen active">
        <div class="container">
            <h1>Imperialism Online</h1>
            <p style="text-align: center; margin-bottom: 20px;">Crea una partita e invita i tuoi amici, o unisciti a una partita esistente!</p>
            <div class="form-group">
                <label for="player-name">Il tuo nome:</label>
                <input type="text" id="player-name" placeholder="Super Giocatore" maxlength="20">
            </div>
            <div class="button-group">
                <button id="create-game-btn" class="btn-primary">Crea Partita</button>
            </div>
            <hr style="margin: 20px 0; border-color: var(--border-color);">
            <div class="form-group">
                <label for="join-code">Codice Partita:</label>
                <input type="text" id="join-code" placeholder="ABCDE" maxlength="5">
            </div>
            <div class="button-group">
                <button id="join-game-btn" class="btn-secondary">Unisciti alla Partita</button>
            </div>
        </div>
    </div>

    <!-- Schermata Lobby -->
    <div id="lobby-screen" class="screen">
        <div class="container">
            <h1>Lobby di Gioco</h1>
            <p>Condividi questo codice con i tuoi amici:</p>
            <div id="game-code-display" class="game-code-display" title="Clicca per copiare">CARICAMENTO...</div>
            <h2 style="margin-top: 20px;">Giocatori Connessi:</h2>
            <ul id="player-list"></ul>
            <div id="loading-spinner" class="spinner" style="display: none;"></div>
            <div class="button-group">
                <button id="start-game-btn" class="btn-primary">Inizia Partita (Min. 2)</button>
                <button id="leave-lobby-btn" class="btn-danger">Esci dalla Lobby</button>
            </div>
        </div>
    </div>

    <!-- Schermata di Gioco -->
    <div id="game-screen" class="screen">
        <div id="game-ui-overlay">
            <button id="leave-game-btn" class="btn-danger">Abbandona</button>
        </div>
        <div id="arena-container">
            <div id="arena"></div>
        </div>
    </div>
    
    <!-- Modale del Voto -->
    <div id="vote-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>La Sfida!</h2>
            <div class="duel-container">
                <div id="attacker-info" class="combatant"></div>
                <div class="vs">VS</div>
                <div id="defender-info" class="combatant"></div>
            </div>
            <h3>Chi vincerà? Vota!</h3>
            <div id="vote-actions" class="vote-actions"></div>
            <div id="vote-timer">20</div>
        </div>
    </div>

    <!-- Schermata dei Risultati -->
    <div id="results-screen" class="screen">
        <div class="container">
            <h1 id="winner-announcement"></h1>
            <div class="ranking-tables">
                <div class="ranking-table">
                    <h2>Classifica Piazzamenti</h2>
                    <table id="placement-table">
                        <thead><tr><th>#</th><th>Personaggio</th><th>Eliminato da</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div class="ranking-table">
                    <h2>Classifica Uccisioni</h2>
                    <table id="kills-table">
                        <thead><tr><th>Personaggio</th><th>Uccisioni</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
            <div class="button-group">
                <button id="rematch-btn" class="btn-primary">Rivincita!</button>
                <button id="new-game-btn" class="btn-secondary">Torna alla Home</button>
            </div>
        </div>
    </div>
    
    <!-- Overlay per Messaggi -->
    <div id="message-overlay" style="display: none;">
        <h2 id="message-text"></h2>
    </div>

    <script type="module">
        // Importa le funzioni di Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, deleteDoc, runTransaction } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
        
        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyAu6Yy9B_VFAek56ZI35lznAlLzRv0G4pY",
            authDomain: "imperialism-online.firebaseapp.com",
            projectId: "imperialism-online",
            storageBucket: "imperialism-online.firebasestorage.app",
            messagingSenderId: "1073749237649",
            appId: "1:1073749237649:web:b8c01c3db78a13fa454430",
            measurementId: "G-7GJK149KRR"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- RIFERIMENTI DOM ---
        const screens = document.querySelectorAll('.screen');
        const homeScreen = document.getElementById('home-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const resultsScreen = document.getElementById('results-screen');

        const playerNameInput = document.getElementById('player-name');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinCodeInput = document.getElementById('join-code');
        const joinGameBtn = document.getElementById('join-game-btn');
        
        const gameCodeDisplay = document.getElementById('game-code-display');
        const playerList = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');

        const arenaContainer = document.getElementById('arena-container');
        const arena = document.getElementById('arena');
        const leaveGameBtn = document.getElementById('leave-game-btn');

        const voteModal = document.getElementById('vote-modal');
        const attackerInfo = document.getElementById('attacker-info');
        const defenderInfo = document.getElementById('defender-info');
        const voteActions = document.getElementById('vote-actions');
        const voteTimer = document.getElementById('vote-timer');

        const winnerAnnouncement = document.getElementById('winner-announcement');
        const placementTableBody = document.querySelector('#placement-table tbody');
        const killsTableBody = document.querySelector('#kills-table tbody');
        const rematchBtn = document.getElementById('rematch-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');

        // --- STATO LOCALE ---
        let currentUser = null;
        let currentGameId = null;
        let unsubFromGame = null;
        let panzoom;
        let localTimers = [];

        // --- FUNZIONI DI NAVIGAZIONE E UI ---
        const showScreen = (screenId) => {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        };

        const showMessage = (text, duration = 3000) => {
            messageText.textContent = text;
            messageOverlay.style.display = 'flex';
            if (duration > 0) {
                setTimeout(() => messageOverlay.style.display = 'none', duration);
            }
        };

        const clearLocalTimers = () => {
            localTimers.forEach(timer => clearInterval(timer));
            localTimers = [];
        };
        
        // --- AUTENTICAZIONE E INIZIALIZZAZIONE ---
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUser = user;
            } else {
                signInAnonymously(auth).catch(error => console.error("Errore di accesso anonimo:", error));
            }
        });

        // --- LOGICA DELLA LOBBY ---
        const createGame = async () => {
            const playerName = playerNameInput.value.trim();
            if (!playerName || !currentUser) {
                showMessage("Per favore, inserisci il tuo nome.", 2000);
                return;
            }

            createGameBtn.disabled = true;
            const gameId = generateGameId();
            const gameRef = doc(db, "games", gameId);

            const initialGameState = {
                gameId: gameId,
                hostId: currentUser.uid,
                players: [{ uid: currentUser.uid, name: playerName }],
                characters: [],
                eliminated: [],
                gameState: "lobby", // Stati: lobby, starting, selecting_attacker, selecting_defender, voting, round_end, finished
                gridSize: 0,
                cols: 0,
                rows: 0,
                currentDuel: null,
                message: `Benvenuto nella lobby! In attesa che l'host inizi la partita.`
            };

            try {
                await setDoc(gameRef, initialGameState);
                joinLobby(gameId, playerName);
            } catch (error) {
                console.error("Errore nella creazione della partita:", error);
                showMessage("Impossibile creare la partita. Riprova.", 3000);
                createGameBtn.disabled = false;
            }
        };

        const joinGame = async () => {
            const playerName = playerNameInput.value.trim();
            const gameId = joinCodeInput.value.trim().toUpperCase();
            if (!playerName || !gameId || !currentUser) {
                showMessage("Per favore, inserisci nome e codice partita.", 2000);
                return;
            }

            joinGameBtn.disabled = true;
            const gameRef = doc(db, "games", gameId);
            
            try {
                 await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) {
                        throw "Partita non trovata!";
                    }

                    const gameData = gameDoc.data();
                    if (gameData.gameState !== 'lobby') {
                        throw "La partita è già iniziata!";
                    }

                    const players = gameData.players;
                    if (!players.some(p => p.uid === currentUser.uid)) {
                        players.push({ uid: currentUser.uid, name: playerName });
                    }
                    transaction.update(gameRef, { players });
                });
                joinLobby(gameId, playerName);
            } catch (error) {
                console.error("Errore nell'unirsi alla partita:", error);
                showMessage("Impossibile unirsi: " + error, 3000);
                joinGameBtn.disabled = false;
            }
        };

        const joinLobby = (gameId, playerName) => {
            currentGameId = gameId;
            localStorage.setItem('playerName', playerName);
            showScreen('lobby-screen');
            listenToGameUpdates(gameId);
        };

        const leaveLobby = async () => {
             if (!currentGameId || !currentUser) return;
             
             const gameRef = doc(db, "games", currentGameId);
             try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) return;

                    let gameData = gameDoc.data();
                    let players = gameData.players.filter(p => p.uid !== currentUser.uid);
                    
                    if (players.length === 0) {
                        transaction.delete(gameRef);
                    } else {
                        // Se l'host se ne va, assegna un nuovo host
                        if (gameData.hostId === currentUser.uid) {
                            gameData.hostId = players[0].uid;
                        }
                        transaction.update(gameRef, { players: players, hostId: gameData.hostId });
                    }
                });
             } catch (error) {
                 console.error("Errore nell'uscire dalla partita: ", error);
             } finally {
                 resetLocalState();
             }
        };

        const listenToGameUpdates = (gameId) => {
            const gameRef = doc(db, "games", gameId);
            if (unsubFromGame) unsubFromGame();

            unsubFromGame = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    showMessage("La partita è stata chiusa dall'host.", 4000);
                    resetLocalState();
                    return;
                }
                const gameData = doc.data();
                updateUI(gameData);
            });
        };

        const updateUI = (gameData) => {
             // Aggiorna la lobby
            if (gameData.gameState === 'lobby') {
                showScreen('lobby-screen');
                gameCodeDisplay.textContent = gameData.gameId;
                playerList.innerHTML = '';
                gameData.players.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name;
                    if (player.uid === gameData.hostId) {
                        const hostTag = document.createElement('span');
                        hostTag.className = 'host-tag';
                        hostTag.textContent = '(Host)';
                        li.appendChild(hostTag);
                    }
                    playerList.appendChild(li);
                });
                startGameBtn.disabled = gameData.players.length < 2 || currentUser.uid !== gameData.hostId;
                rematchBtn.disabled = currentUser.uid !== gameData.hostId;
            }
            
            // Gestione transizioni di stato
            switch(gameData.gameState) {
                case 'starting':
                    showScreen('game-screen');
                    showMessage("La partita sta iniziando...", 0);
                    createArena(gameData);
                    break;
                case 'selecting_attacker':
                case 'selecting_defender':
                    showScreen('game-screen');
                    showMessage(gameData.message, 0);
                    updateArena(gameData);
                    // L'host gestisce le animazioni
                    if (currentUser.uid === gameData.hostId) {
                        handleRoundAnimations(gameData);
                    }
                    break;
                case 'voting':
                    showScreen('game-screen');
                    updateArena(gameData);
                    showMessage(`È ora di votare!`, 0);
                    showVoteModal(gameData);
                    break;
                case 'round_end':
                     showScreen('game-screen');
                     if(voteModal.style.display === 'flex') voteModal.style.display = 'none';
                     showMessage(gameData.message, 3000);
                     updateArena(gameData);
                     clearLocalTimers();
                     break;
                case 'finished':
                    showScreen('results-screen');
                    if (unsubFromGame) unsubFromGame(); // Smettiamo di ascoltare
                    unsubFromGame = null;
                    displayResults(gameData);
                    break;
            }
        };

        const handleStartGame = async () => {
            if (!currentGameId || !currentUser) return;

            const gameRef = doc(db, "games", currentGameId);
            const gameDoc = await getDoc(gameRef);
            if (!gameDoc.exists()) return;
            const gameData = gameDoc.data();
            const players = gameData.players;

            // Crea personaggi semplici basati sui giocatori
            const characters = players.map((player, index) => ({
                id: player.uid,
                name: player.name,
                imgSrc: `https://placehold.co/100x100/${getRandomColor(true)}/ffffff?text=${player.name.charAt(0)}`,
                color: getRandomColor(),
                territories: [],
                eliminations: 0,
            }));

            const shuffledCharacters = shuffleArray([...characters]);
            shuffledCharacters.forEach((char, index) => {
                char.territories = [index];
            });

            const gridSize = characters.length;
            const ratio = window.innerWidth / window.innerHeight;
            const cols = Math.ceil(Math.sqrt(gridSize * ratio));
            const rows = Math.ceil(gridSize / cols);
            
            await updateDoc(gameRef, {
                gameState: 'starting',
                characters: shuffledCharacters,
                eliminated: [],
                gridSize,
                cols,
                rows,
                message: 'La partita sta per iniziare...'
            });
            
            // Dopo un breve ritardo, inizia il primo round
            setTimeout(() => {
                updateDoc(gameRef, { gameState: 'selecting_attacker', message: "Inizio Round!" });
            }, 3000);
        };
        
        // --- LOGICA DI GIOCO (gestita dall'host) ---
        let isAnimating = false;
        const handleRoundAnimations = async (gameData) => {
            if (isAnimating) return;
            isAnimating = true;

            const gameRef = doc(db, "games", currentGameId);

            if (gameData.gameState === 'selecting_attacker') {
                const activeCharacters = gameData.characters;
                
                // Animazione Roulette
                await new Promise(resolve => {
                    let rouletteCount = 0;
                    let lastHighlight = null;
                    const rouletteInterval = setInterval(() => {
                        if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                        const randomChar = activeCharacters[Math.floor(Math.random() * activeCharacters.length)];
                        const cell = arena.querySelector(`[data-owner-id='${randomChar.id}']`);
                        if (cell) {
                            cell.classList.add('roulette-active');
                            lastHighlight = cell;
                        }
                        rouletteCount++;
                        if (rouletteCount > 20) {
                            clearInterval(rouletteInterval);
                            if (lastHighlight) lastHighlight.classList.remove('roulette-active');
                            resolve();
                        }
                    }, 150);
                });

                const attacker = activeCharacters[Math.floor(Math.random() * activeCharacters.length)];
                await updateDoc(gameRef, { 
                    'currentDuel.attackerId': attacker.id,
                    gameState: 'selecting_defender',
                    message: `${attacker.name} si prepara ad attaccare!`
                });
            } else if (gameData.gameState === 'selecting_defender' && gameData.currentDuel.attackerId) {
                const attacker = gameData.characters.find(c => c.id === gameData.currentDuel.attackerId);
                const neighbors = getValidNeighbors(attacker, gameData);

                if (neighbors.length === 0) {
                     await updateDoc(gameRef, { 
                        gameState: 'selecting_attacker', 
                        message: `${attacker.name} non ha bersagli! Si ricomincia.`
                    });
                    isAnimating = false;
                    return;
                }
                
                // Animazione Bersaglio
                await new Promise(resolve => {
                    let targetCount = 0;
                    let lastHighlight = null;
                    const targetInterval = setInterval(() => {
                        if (lastHighlight) lastHighlight.classList.remove('target-highlighted');
                        const randomTarget = neighbors[Math.floor(Math.random() * neighbors.length)];
                        const targetCell = arena.querySelector(`[data-index='${randomTarget.cellIndex}']`);
                        if (targetCell) {
                            targetCell.classList.add('target-highlighted');
                            lastHighlight = targetCell;
                        }
                        targetCount++;
                        if (targetCount > 15) {
                            clearInterval(targetInterval);
                            if (lastHighlight) lastHighlight.classList.remove('target-highlighted');
                            resolve();
                        }
                    }, 150);
                });

                const defender = neighbors[Math.floor(Math.random() * neighbors.length)].owner;
                 await updateDoc(gameRef, {
                    'currentDuel.defenderId': defender.id,
                    'currentDuel.votes': {},
                    gameState: 'voting',
                    message: `${attacker.name} attacca ${defender.name}!`
                });
                startVoteTimerOnHost(gameData);
            }
            isAnimating = false;
        };

        const startVoteTimerOnHost = (gameData) => {
            let timeLeft = 20;
            const timerInterval = setInterval(async () => {
                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    await resolveDuel();
                }
            }, 1000);
            localTimers.push(timerInterval);
        };
        
        const castVote = async (winnerId) => {
            if (!currentGameId || !currentUser) return;
            const voteBtn = document.querySelector(`.vote-btn[data-winner-id="${winnerId}"]`);
            if (voteBtn) voteBtn.disabled = true; // Disabilita subito per feedback
            
            const gameRef = doc(db, "games", currentGameId);
            const votePath = `currentDuel.votes.${currentUser.uid}`;
            await updateDoc(gameRef, { [votePath]: winnerId });
        };
        
        const resolveDuel = async () => {
            if (!currentGameId) return;
            const gameRef = doc(db, "games", currentGameId);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw "Partita non trovata.";
                    let gameData = gameDoc.data();

                    if(gameData.gameState !== 'voting') return; // Qualcuno l'ha già risolto
                    
                    const { attackerId, defenderId, votes } = gameData.currentDuel;
                    const voteCounts = { [attackerId]: 0, [defenderId]: 0 };
                    
                    for (const voterId in votes) {
                        voteCounts[votes[voterId]]++;
                    }

                    let winnerId, loserId;
                    if (voteCounts[attackerId] > voteCounts[defenderId]) {
                        winnerId = attackerId;
                        loserId = defenderId;
                    } else if (voteCounts[defenderId] > voteCounts[attackerId]) {
                        winnerId = defenderId;
                        loserId = attackerId;
                    } else {
                        // Pareggio, sceglie casualmente
                        winnerId = Math.random() < 0.5 ? attackerId : defenderId;
                        loserId = winnerId === attackerId ? defenderId : attackerId;
                    }
                    
                    let characters = gameData.characters;
                    let winnerData = characters.find(c => c.id === winnerId);
                    let loserData = characters.find(c => c.id === loserId);

                    winnerData.eliminations++;
                    winnerData.territories.push(...loserData.territories);

                    let eliminated = gameData.eliminated;
                    eliminated.push({ ...loserData, eliminatedBy: winnerData.name });
                    characters = characters.filter(c => c.id !== loserId);
                    
                    const message = `${winnerData.name} ha sconfitto ${loserData.name}!`;

                    if (characters.length <= 1) {
                         transaction.update(gameRef, {
                            gameState: 'finished',
                            characters,
                            eliminated,
                            message: `La partita è finita! Il vincitore è ${characters[0].name}!`
                        });
                    } else {
                         transaction.update(gameRef, {
                            gameState: 'round_end',
                            characters,
                            eliminated,
                            currentDuel: null,
                            message
                        });
                        
                        // Pianifica il prossimo round (lo farà il client dell'host)
                        setTimeout(() => {
                            if (currentUser.uid === gameData.hostId) {
                                updateDoc(gameRef, { gameState: 'selecting_attacker', message: 'Inizio nuovo round!' });
                            }
                        }, 4000);
                    }
                });

            } catch(error) {
                console.error("Errore nella risoluzione del duello:", error);
            }
        };

        // --- FUNZIONI DI VISUALIZZAZIONE GIOCO ---
        const createArena = (gameData) => {
            arena.innerHTML = '';
            arena.style.gridTemplateColumns = `repeat(${gameData.cols}, 100px)`;
            const grid = new Array(gameData.cols * gameData.rows).fill(null);
            
            gameData.characters.forEach(char => {
                char.territories.forEach(index => {
                    grid[index] = char;
                });
            });

            for(let i = 0; i < grid.length; i++) {
                const character = grid[i];
                const cell = document.createElement('div');
                cell.classList.add('character-cell');
                cell.dataset.index = i;
                if (character) {
                    cell.dataset.ownerId = character.id;
                    cell.style.border = `3px solid ${character.color}`;
                    cell.innerHTML = `
                        <img src="${character.imgSrc}" alt="${character.name}" onerror="this.src='https://placehold.co/100x100/1a1a1a/444?text=X'">
                        <div class="character-name">${character.name}</div>
                    `;
                } else {
                    cell.style.visibility = 'hidden';
                }
                arena.appendChild(cell);
            }
            setupPanzoom();
        };

        const updateArena = (gameData) => {
            // Rimuovi vecchi highlight
            document.querySelectorAll('.attacker-selected, .target-highlighted').forEach(el => {
                el.classList.remove('attacker-selected', 'target-highlighted');
            });
            
            gameData.characters.forEach(character => {
                character.territories.forEach(index => {
                    const cell = arena.querySelector(`[data-index='${index}']`);
                    if (cell && cell.dataset.ownerId !== character.id) {
                         cell.dataset.ownerId = character.id;
                         cell.style.borderColor = character.color;
                         cell.querySelector('img').src = character.imgSrc;
                         cell.querySelector('.character-name').textContent = character.name;
                    }
                });
            });

            if (gameData.currentDuel?.attackerId) {
                const attackerCell = arena.querySelector(`[data-owner-id='${gameData.currentDuel.attackerId}']`);
                if(attackerCell) attackerCell.classList.add('attacker-selected');
            }
        };

        const showVoteModal = (gameData) => {
             const { attackerId, defenderId, votes } = gameData.currentDuel;
             const attacker = gameData.characters.find(c => c.id === attackerId) || gameData.eliminated.find(c => c.id === attackerId);
             const defender = gameData.characters.find(c => c.id === defenderId) || gameData.eliminated.find(c => c.id === defenderId);

             if (!attacker || !defender) return;
            
             attackerInfo.innerHTML = `<img src="${attacker.imgSrc}"><h3>${attacker.name}</h3>`;
             defenderInfo.innerHTML = `<img src="${defender.imgSrc}"><h3>${defender.name}</h3>`;
             
             const voteCounts = { [attackerId]: 0, [defenderId]: 0 };
             if(votes) {
                Object.values(votes).forEach(vote => voteCounts[vote]++);
             }

             voteActions.innerHTML = `
                <button class="btn-primary vote-btn" data-winner-id="${attackerId}">VOTA ${attacker.name} <span class="vote-count">${voteCounts[attackerId]}</span></button>
                <button class="btn-primary vote-btn" data-winner-id="${defenderId}">VOTA ${defender.name} <span class="vote-count">${voteCounts[defenderId]}</span></button>
             `;
             
             const hasVoted = votes && votes[currentUser.uid];
             document.querySelectorAll('.vote-btn').forEach(btn => {
                if(hasVoted) btn.disabled = true;
                btn.addEventListener('click', () => castVote(btn.dataset.winnerId));
             });

             voteModal.style.display = 'flex';
             
             clearLocalTimers();
             let timeLeft = 20;
             voteTimer.textContent = timeLeft;
             const timerInterval = setInterval(() => {
                 timeLeft--;
                 voteTimer.textContent = timeLeft;
                 if (timeLeft <= 0) {
                      clearInterval(timerInterval);
                      voteModal.style.display = 'none';
                 }
             }, 1000);
             localTimers.push(timerInterval);
        };
        
        const displayResults = (gameData) => {
            const winner = gameData.characters[0];
            winnerAnnouncement.textContent = `IL VINCITORE È ${winner.name}!`;

            placementTableBody.innerHTML = `<tr><td>1</td><td><img src="${winner.imgSrc}" class="rank-img">${winner.name}</td><td>Vincitore</td></tr>`;
            [...gameData.eliminated].reverse().forEach((char, i) => {
                placementTableBody.innerHTML += `<tr><td>${i + 2}</td><td><img src="${char.imgSrc}" class="rank-img">${char.name}</td><td>${char.eliminatedBy}</td></tr>`;
            });

            const allFighters = [winner, ...gameData.eliminated].sort((a, b) => b.eliminations - a.eliminations);
            killsTableBody.innerHTML = '';
            allFighters.forEach(char => {
                killsTableBody.innerHTML += `<tr><td><img src="${char.imgSrc}" class="rank-img">${char.name}</td><td>${char.eliminations}</td></tr>`;
            });
        };

        const handleRematch = async () => {
             if (!currentGameId || !currentUser) return;
             const gameRef = doc(db, "games", currentGameId);
             
             try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) return;
                const gameData = gameDoc.data();
                
                const newPlayersList = gameData.players.filter(p => [gameData.hostId, ...gameData.characters.map(c => c.id), ...gameData.eliminated.map(e => e.id)].includes(p.uid));

                await updateDoc(gameRef, {
                    gameState: 'lobby',
                    players: newPlayersList, // Ripristina solo i giocatori che hanno finito
                    characters: [],
                    eliminated: [],
                    currentDuel: null
                });
                listenToGameUpdates(currentGameId); // Riavviamo l'ascolto
             } catch (error) {
                 console.error("Errore nella rivincita:", error);
             }
        };


        // --- FUNZIONI DI UTILITÀ ---
        const resetLocalState = () => {
             if (unsubFromGame) unsubFromGame();
             unsubFromGame = null;
             currentGameId = null;
             isAnimating = false;
             clearLocalTimers();
             showScreen('home-screen');
        };

        const generateGameId = () => Math.random().toString(36).substring(2, 7).toUpperCase();
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };
        const getRandomColor = (forPlaceholder = false) => {
            const letters = '0123456789ABCDEF';
            let color = forPlaceholder ? '' : '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        };
        const getValidNeighbors = (character, gameData) => {
            const neighbors = [];
            const { cols, rows } = gameData;
            character.territories.forEach(index => {
                const x = index % cols;
                const y = Math.floor(index / cols);
                const directions = [{ dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }];
                directions.forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
                        const neighborIndex = newY * cols + newX;
                        const owner = gameData.characters.find(c => c.territories.includes(neighborIndex));
                        if (owner && owner.id !== character.id && !neighbors.some(n => n.owner.id === owner.id)) {
                            neighbors.push({ owner, cellIndex: neighborIndex });
                        }
                    }
                });
            });
            return neighbors;
        };
        
        const setupPanzoom = () => {
             if (panzoom) panzoom.destroy();
             panzoom = Panzoom(arena, { maxScale: 5, minScale: 0.2, canvas: true });
             arenaContainer.addEventListener('wheel', panzoom.zoomWithWheel);
             setTimeout(() => {
                const containerRect = arenaContainer.getBoundingClientRect();
                const elemRect = arena.getBoundingClientRect();
                if (elemRect.width === 0) return;
                const scale = Math.min(containerRect.width / elemRect.width, containerRect.height / elemRect.height) * 0.95;
                panzoom.zoom(scale, { animate: true });
             }, 250);
        };


        // --- EVENT LISTENERS ---
        createGameBtn.addEventListener('click', createGame);
        joinGameBtn.addEventListener('click', joinGame);
        leaveLobbyBtn.addEventListener('click', leaveLobby);
        startGameBtn.addEventListener('click', handleStartGame);
        leaveGameBtn.addEventListener('click', leaveLobby);
        rematchBtn.addEventListener('click', handleRematch);
        newGameBtn.addEventListener('click', resetLocalState);
        gameCodeDisplay.addEventListener('click', () => {
             navigator.clipboard.writeText(gameCodeDisplay.textContent).then(() => {
                showMessage('Codice copiato!', 1500);
             });
        });

        // --- Inizializzazione ---
        playerNameInput.value = localStorage.getItem('playerName') || '';
    </script>
</body>
</html>

